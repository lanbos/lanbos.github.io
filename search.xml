<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用markdown快速生成类PPT的html]]></title>
    <url>%2F2018%2F07%2F19%2Ftools%2Fh5PPT%2F</url>
    <content type="text"><![CDATA[快速生成开发者讲ppt的场景不少，但是身为前端开发工程师，拖拖拽拽生成ppt一点都不Geek，最近发现了一款能快速用md生成类PPT的html的库，好用到爆炸：remark官方事例简介明了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz); @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic); @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic); body &#123; font-family: 'Droid Serif'; &#125; h1, h2, h3 &#123; font-family: 'Yanone Kaffeesatz'; font-weight: normal; &#125; .remark-code, .remark-inline-code &#123; font-family: 'Ubuntu Mono'; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;textarea id="source"&gt;class: center, middle# Title---# Agenda1. Introduction2. Deep-dive3. ...---# Introduction .green[ 自带语法赋class ] &lt;/textarea&gt; &lt;script src="https://cdn.bootcss.com/remark/0.14.0/remark.min.js"&gt; &lt;/script&gt; &lt;!-- 换成国内的cdn加载速度更快 --&gt; &lt;script&gt; var slideshow = remark.create(&#123; ratio: '16:9', click: true, highlightLanguage: 'javascript', highlightStyle: 'solarized-light', &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 只需在textarea标签里写md就可以了，如果对样式不满足，直接写css，对h1,h2,ul,li等常用标签附样式即可。非常适合快速简单展示内容的场景。 炫酷生成当然remark虽然很强大使用很便捷，但是当你需要给客户或者在其他较为正式的场合演示的时候，你需要的是炫酷的动画，和抓眼球的交互。这时候你需要的是Reveal.js,至于Reveal.js的使用方法网上教程很多，个人感觉使用起来不如remark 简单，也不够geek。当然通过web方式生成幻灯的库有很多，可详细看几个秒杀PPT的高（zhe）大(teng)上(ren)的幻灯工具]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主旋律能不能成变奏曲？——观《战狼2》的脑洞]]></title>
    <url>%2F2018%2F07%2F09%2Fzhanlang2%2F</url>
    <content type="text"><![CDATA[无剧透的短影评作为主旋律电影给四星没问题。全片无尿点，动作戏还不错，略有夸张的成分但远不至于“手撕鬼子”。没有像第一部那样反复喊口号，最后的主旋律煽情却更燃。正片结束没等彩蛋开始影院里已经有人鼓掌了。再考虑到达康书记和东来局长的混入，影片加到满分都没问题。吐槽一下，战狼系列是不是可以作为撩妹的反面教材？网评说吴京是直男癌的好像有点道理。。。 有剧透的大脑洞看之前网上已经有人在说这是中国的“超级英雄”电影，要是从这个角度出发这片给三星都嫌多。主旋律毕竟不能成变奏曲，即便吴京再灭几个装甲师，再吹几瓶茅台，也不会允许我军里有超级英雄的存在，虽然个人英雄主义已经人人都看的出来，但是战狼系列还是彻彻底底的把挥扬主旋律定为根本基调。然后下面我开始扯脑洞： 只差一点就能变成战狼侠剧情中冷锋先得致命传染病，后被新研发出的解药治好，剧情都铺垫到这了，冷锋变身战狼侠观众很容易就能脑补出来啊，治好之后获得个把超能力不是很正常么？然后再让作为解药的黑人小女孩领了便当（要是嫌太残忍可以设定为能吹一箱茅台的基因才能获得超能力），战狼侠的出身就能完美解决。脑洞到这的话就得说说为什么这部“战狼侠”只能得三星。 超级英雄电影最重要的吸睛点超级英雄系列电影获得口碑和票房双丰收的根本是什么？大场面？高颜值？大脑洞？牛逼特效？其实最关键的是要有个嘴炮角色。。。嘴炮让全片节奏张弛有度，让观众观影结束后回味无穷，让角色塑造深得人心。有这样嘴炮的超级英雄影片大都口碑和票房拿到了双丰收。星爵，小贱贱，蚁人，小蜘蛛，钢铁侠，等等。。。漫威吃到了嘴炮成功的甜头，现在感觉在把所有电影里都安插了嘴炮角色，这也是其全面超越dc系列的杀手锏。反观战狼里的嘴炮还是差不少，其实吴京本身就有嘴炮的潜力，冷锋的角色是吴京的本色出演，有“兵痞”的既视感，冷锋角色文戏基本就是垫剧情和弘扬主旋律但也能看出其嘴够臭，全片已经不再禁“国骂”和“国际骂”，那再加点嘴炮和freestyle让气氛更欢快点岂不是更好。张翰的富二代角色也适合当嘴炮，全片的幽默点张翰承担了不少，作为男三（什么？于谦才是男三？东来局长才是男三？），如果变成了嘴炮这个已被洗白的角色肯定能继续在第三部里成为亮点。达康书记不能变成嘴炮，因为达康书记变成嘴炮光芒必将盖过男一，干脆把超能力也给达康书记吧。 文戏太少其实全片无尿点全是快节奏的武戏感觉是挺爽，但观众到后来会有疲倦感，这也是嘴炮调节影片节奏的作用。再加上“直男癌”从头到尾，我至今没感觉到冷锋和龙小云或者第二部剧女主之间有什么刻骨铭心的。。。彩蛋中似乎透露龙小云没死，而且表情有些诡异，要是第三部黑化了的话那真是神来之笔了。 反派不走心也不能说反派演员演的不走心，的确是戏份太少了。记得有个亚洲雇佣兵一直臭着长脸，感觉应该是个小boss级别的，然而后面几个镜头就死了，实在可惜。超级英雄电影反派出彩的太多了，甚至有的反派因太受欢迎洗白的例子也不少，战狼的反派太脸谱化，可能也是迫不得已，毕竟要求，正的坚决不能受到质疑，有邪的必须彻底根除，所以不会看到亦正亦邪的受欢迎反派。还是看下一部龙小云会不会黑化吧。 票钱还是值了脑洞就说这么多，战狼让我找回了些小时候看冲出亚马逊时的感觉，虽然作为主旋律电影变奏的可能性很小，但我仍会怀揣不切实际的脑洞为下一部贡献票房。]]></content>
      <categories>
        <category>todo</category>
      </categories>
      <tags>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac的终端上展示树形目录结构]]></title>
    <url>%2F2018%2F07%2F09%2Ftools%2Ftree_base%2F</url>
    <content type="text"><![CDATA[本文参考mac 下的 tree 命令 终端展示你的目录树结构 很多时候需要在终端中查看目录结构，而ls命令并不够用。Linux有tree命令可以更直观的展示出文件的目录结构。然而在mac上没有tree命令，只能通过复杂的shell命令来代替：1find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g' 然后在zsh或者其他bash的配置文件中把上述命令拷贝进去来使用，这样并不方便而且无法指定层级展示。借助mac上的包管理器brew可以安装一个很便利的工具:12brew install treetree -help 帮助里列举了很多方法，最常用的是tree -L 层级指定层级查看。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>工具插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端代码演示神器jsbin]]></title>
    <url>%2F2018%2F07%2F09%2Ftools%2Fjsfiddle_base%2F</url>
    <content type="text"><![CDATA[之前在blog中嵌入代码都是使用markdown格式的代码嵌入功能，这样虽然很方便但是今天在技术blog上发现一种更利于展示前端代码demo的方式，就是类似于jsbin的在线编辑器。打开jsbin官网，界面类似于界面可以直观的看到html，js，css，控制台和输出视图。可以选择各板块是否显示。 插入js，css库推荐手动找到相应库的cdn直接用标签在html板块中引入。点Add library直接添加不敢保证相关库的加载速度。 接口测试可以用jsonp技术调用在线的接口来获取接口数据进行展示，当然只能是get请求，并且接口支持jsonp。 分享编辑完代码后可以用快捷键cmd+s保存，然后点左上角的share弹出如下弹窗即可以选择用链接分享给别人，或者用html代码嵌入到自己的网页中（其实就是iframe）展示。 和jsfiddle对比jsfiddle也是很多人使用的在线编辑器。 和jsfiddle对比jsbin有自带的控制台，jsfiddle需要引https://getfirebug.com/firebug-lite.js库来模拟一个firebug控制台。 jsbin分享没有暗色皮肤，可能在嵌入网站时会影响网站整体风格。 jsbin代码片段的管理不如jsfiddle直观。 两者服务器应该都是在国外，但是jsbin加载速度更快一些，jsfiddle有时会被墙，jsbin有可可靠的cmd+s保存快捷键，防止代码编辑到一半丢失。总之jsfiddle在颜值上率胜一筹，jsbin更加实用一些。国内替代品国内的runjs算是比较著名，但是界面丑陋功能难用，唯一的优点就是加载速度快，而且感觉是很久没有更新维护过了，不推荐使用。ps： 还搜到了名字挺山寨的jsrun。。。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>工具插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gist工作流sftp搭建实践]]></title>
    <url>%2F2018%2F07%2F09%2Ftools%2Fftp_setting%2F</url>
    <content type="text"><![CDATA[最近装了两个服务器，对于web前端来说装环境这种事的确是头疼，准备下一步看看docker了。在配置lnmp的过程中看到lnmp.org官网提供的一键安装脚本很酷1wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp 其实就是用wget远程下载了lnmp的压缩包，解压，然后安装。wget配合远程的脚本的确是能实现很多的“一行命令安装（执行）**”。远程脚本有个很好的存放地点就是github提供的gist服务。于是结合wget,gist,python,shell实现了”一行命令装sftp”。 安装wgetwget是linux上标配的下载程序，mac上默认是没有wget程序的，需要用brew进行安装：1234# 如果没有安装brew需要安装brewruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"# 安装wgetbrew install wget gistgist服务是github提供的非常强大的功能，Gist介绍与用法.我主要用gist的两个功能： 备份一些自用脚本和配置文件 用md写一些简单的便签便于分享，能在一定程度上代替云笔记gist配合gisto使用的话可以满足你对代码snippets管理和分享的全部幻想。（gisto墙内可能无法下载，请自行解决） 写脚本整个sftp设置参考Linux（CentOS）上配置 SFTP,只是用python3让整个设置自动化，python2不一定兼容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# -*- coding: utf-8 -*- import osimport sysimport shutilimport retry: paths = sys.argv[1] userName=sys.argv[2]except: paths = "www" userName="sftpuser"class SftpSetting(): def __init__(self): self.pathName = "/datas/" + paths # sftp目录 self.usrName =userName # sftp用户名 self.filetxt = ''' Subsystem sftp internal-sftp #这行指定使用sftp服务使用系统自带的internal-sftpMatch User &#123;1&#125; #这行用来匹配用户__sftpFlagStatusChrootDirectory &#123;0&#125; #用chroot将用户的根目录指定到/datas/www ，这样用户就只能在/datas/www下活动AllowTcpForwarding noForceCommand internal-sftp #指定sftp命令 '''.format(self.pathName, self.usrName) self.step1_init() self.step2_setfile1() self.step3_setWritedir() self.step4() os.system("service sshd restart") # 初始化用户组等 def step1_init(self): str1 = "groupadd sftp&amp;&amp;useradd -g sftp -s /bin/false &#123;1&#125;&amp;&amp;passwd &#123;1&#125;&amp;&amp;mkdir &#123;0&#125;&amp;&amp;usermod -d &#123;0&#125; &#123;1&#125;".format( self.pathName, self.usrName) os.system(str1) # 编辑sshd_config文件 def step2_setfile1(self): fo = open("/etc/ssh/sshd_config", "r+") s = fo.read() # 读出 fo.seek(0, 0) str1 = re.sub(r'[\s]*[^#]Subsystem[\s]*sftp[\s]*\/usr\/libexec\/openssh\/sftp-server', "Subsystem sftp /usr/libexec/openssh/sftp-server", s) str2 = re.sub( r'PasswordAuthentication[\s]*no', "PasswordAuthentication yes", str1) fo.truncate() # 清空文件 fo.write(str2) if "__sftpFlagStatus" not in str2: fo.write(self.filetxt) fo.close() # 给sftp开放读写权限 def step3_setWritedir(self): str1 = "chown -R root:root &#123;0&#125;&amp;&amp;chmod 755 &#123;0&#125;&amp;&amp;mkdir &#123;0&#125;/&#123;1&#125;&amp;&amp;chown -R &#123;1&#125;:sftp &#123;0&#125;/&#123;1&#125;/&amp;&amp;chmod 755 &#123;0&#125;/&#123;1&#125;/".format( self.pathName, self.usrName) os.system(str1) def step4(self): f = open("/etc/sysconfig/selinux", "r+") s = f.read() f.seek(0, 0) f.truncate() # 清空文件 f.write(s.replace("SELINUX=enforcing", "SELINUX=disabled")) f.close()def main(): sftp = SftpSetting()if __name__ == '__main__': main() 写好脚本上传到gist：https://gist.githubusercontent.com/lanbos/adac5634593c6eb3f8d20c84cd4100d4/raw/70389d8ec59349d7d128a0ca2fd57d1effb147ba/sftpSet.py 最终命令为：1wget https://gist.githubusercontent.com/lanbos/adac5634593c6eb3f8d20c84cd4100d4/raw/edd55f701b47371d81c9736f2082d7cb18e2ed9b/sftpSet.py&amp;&amp;python3 sftpSet.py www sftpuser www为目录名，sftpuser为用户名。本脚本在阿里云和谷歌云上实验成功，其他vps不保证。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html代码检测工具htmlhint]]></title>
    <url>%2F2018%2F07%2F09%2Ftools%2Fhtmlhint_base%2F</url>
    <content type="text"><![CDATA[简介在编辑html过程中尝尝因为反复的编辑文档会出现一些标签没有闭合等错误，这种错误若是通过人工排查比较麻烦，npm上有一款工具是专门检查html文档格式的工具——htmlhint. 安装需要node环境，在终端中运行：1npm install htmlhint -g --save 安装后有具体的使用说明。 简单使用直接在终端中输入htmlhint和需要检查的文件或者文件夹即可1htmlhint path/file/dir 配合编辑器使用vscode中直接在商店中搜索htmlhint，找到后下载即可，重启后插件自动运行，在编辑html文件时若有类似于标签未闭合的情况，会有错误提示。sublime中对应的插件叫做Sublime-htmlhint，安装插件后，打开Preferences &gt; Package Settings &gt; Sublime-htmlhint &gt; Setting - User中配置nodejs的命令路径和htmlhint的命令路径，然后即可运行检查，在mac中运行快捷键为Ctrl+Shift+J。 参考HTMLHint官方githubSublime-htmlhint插件github]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>工具插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常见网页尺寸获取]]></title>
    <url>%2F2018%2F07%2F09%2Ftools%2Fh5ViewCommon%2F</url>
    <content type="text"><![CDATA[移动端常用代码显示手机尺寸宽度：12345678910111213141516var s = "网页可见区域宽 ："+ document.body.clientWidth; s += "\r\n网页可见区域高："+ document.body.clientHeight; s += "\r\n网页可见区域高："+ document.body.offsetHeight +" (包括边线的宽)"; s += "\r\n网页正文全文宽："+ document.body.scrollWidth; s += "\r\n网页正文全文高："+ document.body.scrollHeight; s += "\r\n网页被卷去的高："+ document.body.scrollTop; s += "\r\n网页被卷去的左："+ document.body.scrollLeft; s += "\r\n网页正文部分上："+ window.screenTop; s += "\r\n网页正文部分左："+ window.screenLeft; s += "\r\n屏幕分辨率的高："+ window.screen.height; s += "\r\n屏幕分辨率的宽："+ window.screen.width; s += "\r\n屏幕可用工作区高度："+ window.screen.availHeight; s += "\r\n屏幕可用工作区宽度："+ window.screen.availWidth; s += "\r\n手机宽："+ document.documentElement.clientWidth; ; s += "\r\n手机高："+ document.documentElement.clientHeight; alert(s); var s = "网页可见区域宽 ：" + document.body.clientWidth; s += "网页可见区域高：" + document.body.clientHeight; s += "网页可见区域高：" + document.body.offsetHeight + " (包括边线的宽)"; s += "网页正文全文宽：" + document.body.scrollWidth; s += "网页正文全文高：" + document.body.scrollHeight; s += "网页被卷去的高：" + document.body.scrollTop; s += "网页被卷去的左：" + document.body.scrollLeft; s += "网页正文部分上：" + window.screenTop; s += "网页正文部分左：" + window.screenLeft; s += "屏幕分辨率的高：" + window.screen.height; s += "屏幕分辨率的宽：" + window.screen.width; s += "屏幕可用工作区高度：" + window.screen.availHeight; s += "屏幕可用工作区宽度：" + window.screen.availWidth; s += "手机宽：" + document.documentElement.clientWidth;; s += "手机高：" + document.documentElement.clientHeight; var box = document.getElementById('box'); box.innerHTML = s;]]></content>
      <categories>
        <category>snippets</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这些年折腾过的编辑器（web开发者编辑器评测）]]></title>
    <url>%2F2018%2F07%2F09%2Ftools%2Feditor_base01%2F</url>
    <content type="text"><![CDATA[写在前面 评测的有,sublime,vscode,atom,brackets，hbuider,eclipse, jetbrains系列的webstorm,pycharm,phpstorm。 vim和EMACS不在测评列，部分ide虽在评测列但是用的不多可能不客观，宇宙第一ide(visual studio)没用过不评测。老古董notpad++等不评测。Dw这种非开发者使用工具不评测。 本人主要使用mac，写web前端，少量写python，php等脚本语言，写c,java等需要编译的语言的请投vs和其他对应ide，markdown书写会在评测中占少量部分。 本人认为合理的工作流是：简单预览和少量编辑的a编辑器加一个主力写代码的b编辑器。非要All in one的可以投vim和EMACS党。 评测维度维度不太全，每个维度0~5分，打分是个人观点，不客观或有错误的轻喷。。。 易用性对开发者操作使用友好程度，汉化情况，下载难度，是否收费等方面。 功能性主要是补全提示，代码跳转，debug等 拓展性包括插件数量（只是个人感觉的数量），社区，可自定义程度 颜值这个就是主观程度了，可以忽略不看。 亮点会写我觉得编辑器最大的亮点，不打分 缺点会写我觉得编辑器最大的缺点，不打分 评测（后有图表）sublime 易用性 3分 功能性 2分 颜值 3分 拓展性 3分 亮点：秒启动，情怀 缺点：略显老态 这个应该是评测中大家使用最广的编辑器了，非常优秀的编辑器，也是现在我作为a编辑器来使用的，打文件秒启动这点可以说很难有替代品。sublime是半收费的，免费用户也可以正常使用只是保存时有烦人的弹窗。sublime的扩展性和功能性即便和近年踊跃出来的编辑器相比也不遑多让，经典的马卡龙配色也是很多开发者深爱的主题配色。略有不足是，插件安装时获取插件列表太慢甚至超时报错（可以下载插件列表自设本地服务加载解决）， 插件和配置文件维护方式和其他新出现的编辑器相比不太友好，期待这款编辑器能有更强大的生命力。 Atom 易用性 5分 功能性 3分 颜值 5分 拓展性 5分 亮点：高颜值，完全开源，扩展性非常高 缺点：性能堪忧 Atom是github官方维护的编辑器基于nodejs开源项目electron，界面简洁大方，非常易于扩展和使用，对编辑markdown也算友好，在意颜值或喜欢折腾的朋友可以使用。至于性能的诟病据说官方在不断使用c++更改底层，随后可能彻底解决问题。 Brackets 易用性 2分 功能性 3分 颜值 4分 拓展性 3分 亮点：神奇的cmd+e 缺点：插件需要翻墙下载 Brackets是Adobe官方维护的编辑器，同样基于nodejs，据说用了高端算法没有Atom编辑器的性能诟病，在实际使用过程中也没有卡顿情况。ctrl+e快捷键非常有意思，可以快速定位html标签对应的css样式。Adobe开发这款软件写html+css非常舒畅，对开发js及其他脚本语言也很友好，可惜插件商店被墙，而且下载应该走的是非http协议，无法挂ss下载，导致易用性和拓展性分低。 hbuider 易用性 4分 功能性 4分 颜值 4+分 拓展性 1分 亮点：前端便捷代码snippets，app开发生态 缺点：拓展性低 hbuider是国内基于eclipse制作的针对前端开发的编辑器。有非常便捷的前端代码块可以飞速开发，我现使用的编辑器的自定义snippets很多都是参考了hbuider代码块。因为是基于eclipse，相当于是ide了，补全和项目构建本身功能已经很强大。但是要想下载eclipse上的插件很多需要下载jdk，因为在底层更改了部分eclipse代码，部分插件下载了jdk也无法使用。hbuider有自身使用套壳js开发app的生态，也是亮点之一，不太了解不做深谈。最后说一下这款编辑器的护眼绿主题，本人是Solarized Light脑残粉，所以觉得很好看，给hbuider颜值打了高分。 eclipse（my-eclipse） 易用性 3分 功能性 4分 颜值 1分 拓展性 4分 亮点：情怀 缺点：臃肿 用eclipse的应该大都是java开发的同学。eclipse是sun公司出品为java开发者提供的一款强大的ide，但近年来有被jetbrains的idea取代的趋势。老程序员应该都有过体验，功能强大，但臃肿卡顿而且不好看。如今搞java的可以看看idea，搞前端的可以看看hbuider。。。 jetbrains系列的webstorm（js）,pycharm(python),phpstorm(php) 易用性 2分 功能性 5分 颜值 2+分 拓展性 2分 亮点：ide首选 缺点：是ide 如果一个开发者选择ide，而且不是在windows平台，那么jetbrains系列是首选。最强大的补全和项目构建功能，能交给机器的一切交给ide，开发者只负责开发逻辑，就是这么强大。至于扩展，ide本身足够强大就不用扩展。我不觉得jetbrains系列好看也没找到好看的皮肤。如果你能够接受用电脑性能换取其他的舒爽开发体验，那么再次强烈推荐jetbrains。 vscode 易用性 4分 功能性 4分 颜值 4分 拓展性 4分 亮点：微软家出品，编辑markdown 缺点：都不是满分 最后的重头戏是我在用的第二个主力编辑器vscode。vscode各项评分没有短板，维护的团队也在很积极的更新，同样是用electron，却比Atom流畅的多。作为宇宙第一ide的轻巧版，vscode其实已经很强大了。vscode有自带终端，丰富的终端启动命令，集成git等等贴心的功能让vscode虽然没有sublime秒启动那么便捷，也没有Atom好看，插件不是最丰富的，功能没有一些ide那么强大，但其日常使用体验可以超过其他编辑器。更何况对于开发者来说用vscode编辑markdown的体验能秒杀一切其他md编辑器。 打分图表123456789| 编辑器 | 易用性 | 功能性 | 颜值 | 拓展性 | 亮点 | 缺点 ||:-------------:|:------:|:------:|:----:|:------:|:---------------------------------:|:--------------------:|| sublime | 3 | 2 | 3 | 3 | 秒启动，情怀 | 略显老态 || Atom | 5 | 3 | 5 | 5 | 高颜值，完全开源，扩展性非常高 | 性能堪忧 || Brackets | 2 | 3 | 4 | 3 | 神奇的`cmd+e` | 插件需要翻墙下载 || hbuider | 4 | 4 | 4+ | 1 | 前端便捷代码snippets，app开发生态 | 拓展性低 || eclipse | 3 | 4 | 1 | 4 | 情怀 | 臃肿 || jetbrains系列 | 2 | 5 | 2+ | 2 | ide首选 | 是ide || vscode | 4 | 4 | 4 | 4 | 微软家出品，编辑md | 都不是满分 | 总结编辑器作为开发者的好伙伴是搭建一个舒适开发环境中重要的一环。现代程序员的编辑器大多不再是电影里那样的黑窗口直接用vi写文本了，功能强大的编辑器降低了程序员行业的入门门槛，让开发者更多精力放在开发逻辑上而不是环境搭建。基本每个开发者都折腾过编辑器，每个编辑器都有不完美的地方，个人认为普通开发者应该把日常使用编辑器和开发ide使用场景分离，例如日常用编辑器sublime、vim、Atom、notpad++等轻型编辑器配合jetbrains系列，eclipse系列，vs系列使用，分离使用场景后才能让各编辑器发挥出最大能力。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>代码编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的简单算法(二)]]></title>
    <url>%2F2018%2F07%2F09%2Freading%2Farithmetic_fun02%2F</url>
    <content type="text"><![CDATA[通过一些博客和《啊哈！算法》了解js的栈，队列 队列问题 队列的定义：队列是一种特 殊的线性结构,它只允许在队列的首部(head)进行删除操作,这称为“出队”,而在队列 的尾部(tail)进行插入操作,这称为“入队”。当队列中没有元素时(即 head==tail),称为 空队列 《啊哈！算法》中的一道题，大体意思是有一串密码规则为：首先将第 1 个数删除,紧接着将第 2 个数放到 这串数的末尾,再将第 3 个数删除并将第 4 个数放到这串数的末尾,再将第 5 个数删除…… 直到剩下最后一个数,将最后一个数也删除。按照刚才删除的顺序,把这些删除的数连在一 起就是这串密码，加密的数字为：“6 3 1 7 5 8 9 2 4”。书中阐述了基本思路，引入两个变量head(剩余数组的第一个元素)和tail(剩余数组的最后一个元素的下一个位置)通过移动head和tail的数值来生成新的数组。代码如下：123456789101112131415var qqArray = [6, 3, 1, 7, 5, 8, 9, 2, 4];var sisRight = function(arr) &#123; var head = 0; var tail = arr.length; var results = []; while (head &lt; tail) &#123; results.push(arr[head]); head++; arr[tail] = arr[head]; tail++; head++; &#125; return results;&#125;sisRight(qqArray); //[6, 1, 5, 9, 4, 7, 2, 8, 3] 栈的概念 “栈（Stack）是限定仅在表尾进行插入或删除操作的线性表。表尾为栈顶（top），表头为栈底（bottom），不含元素的空表为空栈。栈又称为后进先出（last in first out）的线性表。” 概念很抽象，大致可模拟理解为只允许一端push和pull的数组。还是通过《啊哈！算法》中的题来理解，题目是判断一个字符串是不是回文字符串（“所谓回文字符 串就是指正读反读均相同的字符序列,如“席主席”、“记书记”、“aha”和“ahaha”均是回 文,但“ahah”不是回文”）。思路是利用回文字符串中心对称的特点来进行解题：123456789101112131415161718192021222324var loopStr = "ahaha";var ifLoopStr = function(str) &#123; var len = str.length; var mid = len / 2 - 1; var backMid = Math.round(len / 2); var top = -1; var s = []; for (var i = 0; i &lt;= mid; i++) &#123; top++; s.push(str[i]); &#125; for (var j = backMid; j &lt; len; j++) &#123; if (str[j] != s[top]) &#123; return false; &#125; top--; &#125; if (top == -1) &#123; return true; &#125; else &#123; return false; &#125;&#125;console.log(ifLoopStr(loopStr));//true 纸牌游戏–小猫钓鱼（栈和队列综合问题）游戏规则：游戏的规则是这样的:将一副扑克牌平均分成两份,每人拿一份。q1先拿出手中的 第一张扑克牌放在桌上,然后q2也拿出手中的第一张扑克牌,并放在q1刚打出的扑克牌 的上面,就像这样两人交替出牌。出牌时,如果某人打出的牌与桌上某张牌的牌面相同,即35啊哈!算法可将两张相同的牌及其中间所夹的牌全部取走,并依次放到自己手中牌的末尾。当任意一人 手中的牌全部出完时,游戏结束,对手获胜。关键代码逻辑是，建一个作为标记的book数组，长度等于所有牌面的最大数字，然后在其中用0和1存储桌面上是否有出现的牌面。具体代码比较有意思，这里用js模拟了一下。(两人手里各有6张牌，牌面最大为9;q1手里牌是：2, 4, 1, 2, 5, 6；q2手里牌是：3, 1, 3, 5, 6, 4)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var q1 = &#123; data: [2, 4, 1, 2, 5, 6], head: 0, tail: 6&#125;var q2 = &#123; data: [3, 1, 3, 5, 6, 4], head: 0, tail: 6&#125;var cardNum = 9;function playcard(q1, q2, cardNum) &#123; // init var _book = []; var _s = &#123; data: [], top: 0 &#125; var _t = null; // init s for (var i = 0; i &lt; cardNum; i++) &#123; _book.push(0); &#125; // start play while (q1.head &lt; q1.tail &amp;&amp; q2.head &lt; q2.tail) &#123; // q1 put card _t = q1.data[q1.head]; if (_book[_t] == 0) &#123; //q1 continu put q1.head++; _s.top++; _s.data[_s.top] = _t; _book[_t] = 1; &#125; else &#123; //q1 collect cards q1.head++; q1.data[q1.tail] = _t; q1.tail++; while (_s.data[_s.top] != _t) &#123; _book[_s.data[_s.top]] = 0; q1.data[q1.tail] = _s.data[_s.top]; q1.tail++; _s.top--; &#125; &#125; // q2 put card _t = q2.data[q2.head]; if (_book[_t] == 0) &#123; //q2 continu put q2.head++; _s.top++; _s.data[_s.top] = _t; _book[_t] = 1; &#125; else &#123; //q2 collect cards q2.head++; q2.data[q2.tail] = _t; q2.tail++; while (_s.data[_s.top] != _t) &#123; _book[_s.data[_s.top]] = 0; q2.data[q2.tail] = _s.data[_s.top]; q2.tail++; _s.top--; &#125; &#125; &#125; // win or lose if (q2.head == q2.tail) &#123; console.log("q1 win and his cards:"); var _results = []; for (var i = q1.head; i &lt;= q1.tail - 1; i++) &#123; _results.push(q1.data[i]); &#125; console.log(_results); if (_s.top &gt; 0) &#123; var deskR = []; for (var i = 1; i &lt;= _s.top; i++) &#123; deskR.push(_s.data[i]); &#125; console.log("cards on desk:" + deskR); &#125; else &#123; console.log("desk empty"); &#125; &#125; else &#123; console.log("q2 win and his cards:"); var _results = []; for (var i = q2.head; i &lt;= q2.tail - 1; i++) &#123; _results.push(q2.data[i]); &#125; console.log(_results); if (_s.top &gt; 0) &#123; var deskR = []; for (var i = 1; i &lt;= _s.top; i++) &#123; deskR.push(_s.data[i]); &#125; console.log("cards on desk:" + deskR); &#125; else &#123; console.log("desk empty"); &#125; &#125; console.log("end");&#125;playcard(q1, q2, cardNum);]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎碎念一篇]]></title>
    <url>%2F2018%2F07%2F09%2Ftodo_201609%2F</url>
    <content type="text"><![CDATA[碎碎念之前之前看了知乎上有问题，“使用 GitHub Pages 来做博客是否道德？”对于这个问题一直在用盗版软件的我感觉有点够不到层次来回答，我先就这么鸡贼的用了，怕被墙还挂了国内的coding（国内一个非常好的代码托管平台，虽然git@osc在操作上更类似github，但是体验和github与coding有一定差距）。15块买了三年域名用github提供的免费服务器和开源的hexo系统花了一天时间把博客基本搭了个样子。反正就是这么鸡贼的借技术博客的名义找了个能让我碎碎念的地方。就像那句话说的“不偷鸡，跟咸鱼有什么区别！” 还是说博客个人既然碎碎念第一篇挂在了todo上就说一下博客的计划。写博客是个包装自己并加深学习印象的好方式，之前大多数学习的笔记都是简单的写在了“为知”上，林林总总有二百多篇，中间还经历了一次从印象笔记转到为知笔记时删除了许多的过程，笔记的剪报是个好功能，看到了好的文章和有用的代码块直接用剪报建了下来然后就扔到了层层文件夹中，只有突然遇到问题的时候才会用检索查一下。所以当时对笔记的要求就是剪报和检索功能一定要强大博客系统不想再走这样的老路子，虽然博客也加了站内检索功能，但是希望是输出一些更多是自己手打的内容，这样才能起到加深印象的作用。当然博客可能会穿插一些像这样的碎碎念内容和感性思维突然抽风写下的苦逼文字。 博客文章计划会逐渐把之前为知笔记上的一些内容移植到博客中，在移植的过程中会自己手打一些自己的理解加上去，不会像之前在笔记上只是简单的粘贴了代码，写了简单的注释，这样才能像个博客。分类方面应该主要是web前端、node和python的一些入门内容，保证一周一篇的更新速度，时隔多年又有了写周记的感觉。虽然不会有什么浏览量，但是在写的过程必然会出错，万一被人指出的话，的确很尴尬，所以要写的严谨，但是严谨过度就失去了写博客的乐趣，变成了写毕业论文，所以我还是会千方百计的为自己的偷懒找借口，保证基本严谨的情况下坚持随意的风格。。。除了技术博客，碎碎念和苦逼文字的比重会不定期添加，之前读书时代有很多苦逼文字，筛选一些不太可笑的会放上来。碎碎念会是对书籍，电影，网络热门话题，生活状态等情况的吐槽，但愿这方便不会大量充斥到整个博客中，先对自己限制一下发一篇碎碎念必须搞一篇技术相关的来补坑。 博客美化计划博客鸡贼的用了开源的hexo和免费的github pages就要面临没有数据库动态更新的尴尬，毕竟有免费的代价。hexo用了ejs模板还是比较简单易懂的，配合简单的js和css应该能做一些美化。当前用了简单的light主题，看到很多人都在用next主题，我正在考虑换主题，甚至自己尝试制作一个皮肤。当前light主题有一些问题，代码块不太好看，引用模块采用的是居中斜体，文章导航位置不科学等问题，随后会一一想办法解决。 更远的计划和其他hexo虽然方便但是每次静态化和部署到github与coding感觉耗时不少，看网上说每次静态化过程都在遍历整个文章随着文章量增加会越来越耗时，到时可能就得考虑租服务器重新搭建网站了。而且用hexo搭建博客除了少量的折腾乐趣外其实对于写博客这件事，无论是从传播还是时间成本和便利性上来说性价比并不高。看到很多人都在用简书和微信公众号等方式传播内容，好在markdown的方式写作可移植性比较高，等有一定文章量后，也会在简书之类的平台上更新一下。]]></content>
      <categories>
        <category>todo</category>
      </categories>
      <tags>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的简单算法]]></title>
    <url>%2F2018%2F07%2F09%2Freading%2Farithmetic_fun01%2F</url>
    <content type="text"><![CDATA[js是弱类型语言，不太适合研究算法和数据结构，这里只是研究一下粗浅的算法，也是对算法入门书籍《啊哈，算法》的一点读书笔记。 冒泡排序冒泡排序的基本思想是:每次比较两个相邻的元素,如果它们的顺序错误就把它们交换 过来。如果有N个需要排序的数字的话，需要循环(N-1)*(N-1)次，排序的复杂程度是O(N²)；123456789101112131415161718192021// js冒泡排序var testArry=[8,100,29,1,888,15,1,6,33];function makeRight(testArry)&#123; var aLen=testArry.length; var a=[]; var midKey=null; for (var i=0;i&lt;aLen;i++)&#123; a.push(testArry[i]); &#125; for (var j=0;j&lt;aLen-1;j++)&#123; for (var k=0;k&lt;aLen-1;k++)&#123; if(a[k]&lt;a[k+1])&#123; midKey=a[k]; a[k]=a[k+1]; a[k+1]=midKey; &#125; &#125; &#125; console.log(a);&#125;makeRight(testArry); 快速排序“快速排序”的思想很简单，整个排序过程只需要三步：1.在数据集之中，选择一个元素作为”基准”（pivot）。2.所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。3.对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。1234567891011121314151617var testArry=[8,100,29,1,888,15,1,6,33];var quickSort=function(arr)&#123; if(arr.length&lt;=1)&#123;return arr;&#125; var pivotIndex=Math.floor(arr.length/2); var pivot=arr.splice(pivotIndex,1)[0]; var left=[]; var right=[]; for (var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right));&#125;;quickSort(testArry); (参考自阮一峰的《快速排序（Quicksort）的Javascript实现》) 排序去重利用之前的快速排序，循环快速排序生成的数组，每两个对比然后把不一样的放进一个新的数组中返回12345678910var noRepeat = function(arr) &#123; var sortArry=quickSort(arr); var results=[]; for(var i=0;i&lt;sortArry.length;i++)&#123; if(sortArry[i]!=sortArry[i+1])&#123; results.push(sortArry[i]); &#125; &#125; return results;&#125;]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo遇到搜索问题小记]]></title>
    <url>%2F2018%2F07%2F09%2Fhexo%2Fhexo_problem01%2F</url>
    <content type="text"><![CDATA[使用了next主题，next官方文档上提供了多种支持搜索的方法，之前用过Swiftype方案，但是服务不太稳定，想了使用本地搜索的方案 安装后问题显现安装1npm install hexo-generator-searchdb --save 站点配置文件：12345search: path: search.xml field: post format: html limit: 10000 主题配置文件： 123 # Local searchlocal_search: enable: true 配置完成重启后，顶部搜索出现但是点击没有反应。开始排查： 排查过程（可忽略不看） hexo项目内搜索search.xml,找到localsearch.swig文件，找到ajax对应代码部分，小吐槽一下，看到源码发现写的如此简单粗暴。。。打开首页跟了下代码，发现ajax请求访问失败了。因为源码中没有写访问失败的调试报错，所以没有显现。加了代码之后发现问题是xml解析错误，有不符合utf8的字符。 解决方案 找到是因为生成的search.xml解析错误就很好排查了，进入xml格式检查网站,把search.xml粘进去一点一点找到报错的地方。最后发现是文章里有一处用了特殊字符，（前段时间vscode和搜狗配合使用会莫名其妙出一些特殊字符），删掉后hexo g重启，问题解决。 附上自己的localsearch.swig 源码简单粗暴，我本来想封装一下顺便改改弹窗样式，但犯懒了，就加了个请求错误报错的代码，帮助排查，随后有空加改吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140 &#123;% if config.search.path %&#125;&lt;script type="text/javascript"&gt; // Popup Window; var isfetched = false; // Search DB path; var search_path = "&#123;&#123; config.search.path &#125;&#125;"; if (search_path.length == 0) &#123; search_path = "search.xml"; &#125; var path = "&#123;&#123; config.root &#125;&#125;" + search_path; // monitor main search box; function proceedsearch() &#123; $("body").append('&lt;div class="popoverlay"&gt;').css('overflow', 'hidden'); $('.popup').toggle(); &#125; // search function; var searchFunc = function (path, search_id, content_id) &#123; $.ajax(&#123; url: path, dataType: "xml", async: true, success: function (xmlResponse) &#123; // get the contents from search data isfetched = true; $('.popup').detach().appendTo('.header-inner'); var datas = $("entry", xmlResponse).map(function () &#123; return &#123; title: $("title", this).text(), content: $("content", this).text(), url: $("url", this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function () &#123; var matchcounts = 0; var str = '&lt;ul class=\"search-result-list\"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); $resultContent.innerHTML = ""; if (this.value.trim().length &gt; 1) &#123; // perform local searching datas.forEach(function (data) &#123; var isMatch = false; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, "").toLowerCase(); var data_url = decodeURIComponent(data.url); var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if (data_title != '') &#123; keywords.forEach(function (keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &gt;= 0 || index_content &gt;= 0) &#123; isMatch = true; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; matchcounts += 1; str += "&lt;li&gt;&lt;a href='" + data_url + "' class='search-result-title'&gt;" + data_title + "&lt;/a&gt;"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, ""); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if (start &lt; 0) &#123; start = 0; &#125; if (start == 0) &#123; end = 50; &#125; if (end &gt; content.length) &#123; end = content.length; &#125; var match_content = content.substring(start, end); // highlight all keywords keywords.forEach(function (keyword) &#123; var regS = new RegExp(keyword, "gi"); match_content = match_content.replace(regS, "&lt;b class=\"search-keyword\"&gt;" + keyword + "&lt;/b&gt;"); &#125;); str += "&lt;p class=\"search-result\"&gt;" + match_content + "...&lt;/p&gt;" &#125; str += "&lt;/li&gt;"; &#125; &#125;) &#125;; str += "&lt;/ul&gt;"; if (matchcounts == 0) &#123; str = '&lt;div id="no-result"&gt;&lt;i class="fa fa-frown-o fa-5x" /&gt;&lt;/div&gt;' &#125; if (keywords == "") &#123; str = '&lt;div id="no-result"&gt;&lt;i class="fa fa-search fa-5x" /&gt;&lt;/div&gt;' &#125; $resultContent.innerHTML = str; &#125;); proceedsearch(); &#125; &#125;).fail(function (data, errStr, err) &#123; console.log(errStr); console.log(err); &#125;) &#125; // handle and trigger popup window; $('.popup-trigger').click(function (e) &#123; e.stopPropagation(); if (isfetched == false) &#123; searchFunc(path, 'local-search-input', 'local-search-result'); &#125; else &#123; proceedsearch(); &#125;; &#125;); function renderData(xmlResponse) &#123; &#125; $('.popup-btn-close').click(function (e) &#123; $('.popup').hide(); $(".popoverlay").remove(); $('body').css('overflow', ''); &#125;); $('.popup').click(function (e) &#123; e.stopPropagation(); &#125;);&lt;/script&gt;&#123;% endif %&#125;]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo其他问题]]></title>
    <url>%2F2018%2F07%2F09%2Fhexo%2Fhexo_others%2F</url>
    <content type="text"><![CDATA[本文记录了一些hexo在使用过程中的一些较为高级使用方式。 草稿功能1.使用情景我习惯把自己的blog当做个人的私人笔记，虽然很多人不建议这么做，因为有各种其他的代替品如：为知笔记，印象笔记等，但是很多笔记不具备分享功能，或者分享功能会另外收费。blog天生具备的传播性很适合作为需要分享的笔记的载体，但之前了解的hexo只是普通的blog功能，作为个人笔记的话又缺少私密性。最近发现的hexo原本具有的草稿功能可以完美解决这个问题。 2.创建草稿首先进入source/目录，之前发布的正式blog都是在_posts目录下新建的markdown文件，若是想创建一篇草稿的话需要创建一个新的目录_draft,创建的草稿不会发布到github上，而且不设置的话hexo甚至不会处理草稿。 3.预览草稿作为个人笔记的话当然草稿是需要自己能看到但是别人是无法看到的。首先打开_config.yml，设置render_drafts为false。然后重新启动hexo服务。变化命令为1hexo s -p 5000 --draft 再预览的话就草稿就能显示出来了。再运行：1hexo d -g 会发现草稿不会提交到github上，但是可以在本地预览。若是想把草稿正式发布到blog上，一种做法是把草稿复制一份到_posts，然后再执行发布命令。或者用publish命令把草稿发布到正式blog中。 hexo命令备忘1234567891011121314#新建bloghexo n &lt;title&gt;#新建草稿hexo n draft &lt;title&gt;#发布草稿到正式bloghexo publish &lt;title&gt;#启动服务hexo s -p5000#启动服务并预览草稿hexo s -p5000 --draft#blog静态化hexo g#blog静态化并发布hexo d -g hexo同时发布到coding和github1.情景github国内众所周知的原因不太稳定，国内有很多优秀的代码托管工具，我一直在用的是淘宝开源的git@osc(码云)，但是奈何之前git@osc没有github的pages功能，看到了这篇博文,知道了coding平台支持pages的功能。 2.在coding上的配置登录coding，注册登录就不提了，首先新建一个和自己用户命相同的公开项目，然后就是设置ssh: 1.打开个人中心的SSH公匙2.如果之前配置过GitHub的公匙的话直接打开,.ssh文件夹里面的_rsa.pub,比如我的是pvphero_rsa.pub,然后将里面的内容全部复制,填写到ssh_rsa公匙处,公匙的名称可以随便起,然后点击’添加’,再接着输入密码就可以完成添加了添加后测试一下1ssh -T git@git.coding.net 如果出现下面的提示则表示公匙添加成功了:1Hello shenzhenwei You've connected to Coding.net by SSH successfully! 2.hexo配置首先配置_config.yml文件12345deploy: type: git repo: github: https://github.com/lanbos/lanbos.github.io.git,master coding: https://git.coding.net/lanbos/lanbos.git,master 3.万网域名双线解析进入万网/阿里云后台，域名解析：添加两条CNAME，分别解析，解析路线选择默认至Coding，海外IP至GitHub。 hexo单页运行js代码其实这是markdown语法的功能，但放在这里的话也算hexo的一点小奇技淫巧，有时候在某篇blog中需要运行单独的js，或者css、html，直接按照html语法写入就可以了，比如可以这么写：1234567891011# 标题内容&lt;p&gt;html内容&lt;/p&gt;&lt;style&gt;p&#123; color:red;&#125;&lt;/style&gt;&lt;script&gt;alert("test");&lt;/script&gt; 这种混写的方式html、css、js代码都会生效，但是需要尽量少用，否则会破坏markdown文件的可读性。在标题处加入layout: false会使整片文章不引用公共的主题样式。 代替多说的评论系统多说最近总报错，disqus又被墙，查了一下，网上说友言比较好，用了一下非常简单，只需要注册让后拷贝代码到页面模板的对应位置即可，只不过这种免费的评论系统能维持多长时间就不知道了。 rsync将blog部署到自己的服务器 在_config.yml中进行如下配置，服务器端需要安装rsync]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack多页面项目实践]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2FwepackPages%2F</url>
    <content type="text"><![CDATA[尽管当下SPA横行，但是多页面项目依然有其存在的意义，webpack这件工具基本是为了SPA而专门准备的，网上看到很多利用webpack构建多页面的教程都是用gulp来配合使用的，在网上看大了一个思路只需对webpack简单配置一下就能实现大多数情景下的多页面项目。本文在vue-cli2.0的基础上做了对多页面vue项目的扩充。 实现思路首先webpack的思想是用js来构建项目的一切，即html只有一个外壳载体，项目的入口文件和执行文件为js，多页面项目肯定是多个入口文件。然后对不同的页面引入不同的入口文件。即： 设置weback.base.coonf.js中的entry,从单一入口变为多入口配置项 在dev和prod的配置项中利用HtmlWebpackPlugin插件来对各个页面引入不同的入口js文件 目录生成第一层目录概览：1234567891011├── README.md├── build├── config├── dist├── index.html├── node_modules├── package-lock.json├── package.json├── pages # 多页面html存放目录├── src #主要源码└── static src目录主要结构：1234567├── App.vue #外壳├── assets # 静态自愿存放├── components #组件目录├── main.js #第一个入口文件保留├── pages #其他页面入口文件存放处├── router #路由└── store #vuex相关 扩展工具方法在build/utils.js底部增加方法123456789101112131415161718192021222324252627282930313233343536373839// 多页面设置class SetPages&#123; constructor()&#123; this.pagesArr=[] this.pagesDir=path.resolve(__dirname,'../pages/'); this.pages=[]; this.pagesEntrys=&#123; app: './src/main.js', &#125;; &#125; init()&#123; this.pagesArr= fs.readdirSync(this.pagesDir); this.pagesArr.forEach(v =&gt; &#123; let fName=path.basename(v, '.html'); let temp=&#123; filename: "", template: '', chunks:['manifest','vendor',fName],//设置允许加载的模块 inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125; temp.filename=path.resolve(__dirname, '../dist/'+v); temp.template=path.resolve(__dirname,this.pagesDir+'/'+v); this.pages.push(temp); this.pagesEntrys[fName]=`./src/pages/$&#123;fName&#125;.js` &#125;); &#125;&#125;let setPages=new SetPages();setPages.init();exports.setPages= setPages.pages;exports.pagesEntrys=setPages.pagesEntrys;//设置各个入口js 该扩展方法主要目的就是读取pages目录下所有的文件名字，生成一个entry入口文件配置项，并去src/pages找到同名的js文件在html中引入。 在各配置文件下使用 build/weback.base.coonf.js中使用 1234567891011module.exports = &#123; context: path.resolve(__dirname, '../'), entry: utils.pagesEntrys,//引入生成的入口文件配置项 output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;,... build/weback.dev.coonf.js和build/weback.pod.coonf.js中都插入 123456789// 复制多页面任务if(utils.setPages.length&gt;0)&#123; utils.setPages.forEach(v =&gt; &#123; v.minify=&#123;&#125; devWebpackConfig.plugins.push( new HtmlWebpackPlugin(v) ) &#125;);&#125; 多页面开发流程在第一层目录pages中新建一个about.html文件，内容复制index.html中的即可，然后在util/pages目录下新建一个与之前生成的html同名的about.js，这个js文件就是一个页面的入口文件，在其中进行开发即可。打包时也会单独打包出一个about.js对应一个页面about.html。 缺点 当页面中引入了过多的第三方库会造成打包出的vendor.js体积过大。解决方案为把不经常改变的第三方库单独用script cdn加载，如lodash，jquery等。强烈建议对element-ui等ui库一定要按需引入组件，否则很容易造成vendor过大。 打包时间很长，不仅是多页面，spa项目里webpack打包速度也是非常的慢，只是多页面项目更加明显而已，暂时没有好的解决方法，只能等webpack新版本解决参考重写webpack多页应用配置脚手架Webpack 打包优化之体积篇]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发问题总结（一）]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2FwechatHardPoints%2F</url>
    <content type="text"><![CDATA[近期连续开发了几个微信公众号的项目并且和甲方配合很难，趟坑无数。罗列如下： 前端技术栈选择（非技术同学可以忽略不看）没有使用单纯的SPA开发方式，是多页面和单页面混合开发方式。~webpack对于多页面项目并不友好~，而且由于之前的项目使用了构建工具fis3，也对其比较了解，所以总体项目构建方式为fis3+vue+less的平滑过渡方案，并自己魔改了一个网上的脚手架，涉及到npm脚本直接写了简单的bash或者python，这套脚手架方案不推荐复用了,随后会弄一个webpack多页面的解决方案，但总体思想是模块化和组件化，js模块、vue组件和less文件还是可以在今后的项目中复用。脚手架地址如下：https://gitee.com/lanbos_document/vue_fis3_ts_less/tree/vuex/vue的ui框架使用了cube-ui（滴滴的ui组件库） 注：最新项目使用了webpack完成了对多页面项目的搭建 vue+better-scroll（非技术同学可以忽略不看）为保证更好的滑动体验，使用了cube-ui scroll模块。首先需要引入对应的样式文件，并且 需要给父级一个很大的固定高度（window.innerHeight） 设置css：123.cube-scroll-wrapper&#123;height: 100%;&#125; android手机当字体小于12px时会导致文字整体偏上 （设计同学敲黑板）(http://imweb.io/topic/5848d0fc9be501ba17b10a94)：1&lt;div class="container"&gt;&lt;span class="content"&gt;testtesttesttesttest&lt;/span&gt;&lt;/div&gt; 1.container &#123; display: table; &#125;.content &#123; background-color: gray; font-size: 10px; display: table-cell; vertical-align: middle; &#125; 内嵌一层，并用table-cell来解决(不好使，测试了各种方式无法解决，尽量不要使用12px以下的文字) 微信jssdk版本 （非技术同学可以忽略不看）把jssdk更新到1.3.1版本，微信官方文档上的1.1版本很多功能不完善，并没有提供新版本的更新说明，尝试找到了1.3.1版本，更新后满足了很多Android上之前没有的功能。1&lt;script type="text/javascript" src="//res.wx.qq.com/open/js/jweixin-1.3.1.js"&gt;&lt;/script&gt; 解决IOS微信webview后退不执行JS的问题（非技术同学可以忽略不看）123456 //解决IOS微信webview后退不执行JS的问题window.onpageshow = function(event) &#123; if (event.persisted) &#123; window.location.reload(); &#125;&#125;; 动画我们可以满足甲方提出的大多数动画效果，但是要明白复杂的动画需要使用逐帧动画技术，即需要设计同学做出动画的每一帧，我们使用css3动画技术进行播放。为保证动画流畅一秒大约为8~12帧，需要设计同学大量的工作，并且要与前端开发的配合调试。动画越复杂需要图片数量越多，会导致网页加载等待时间长，耗费用户大量流量等问题。 声音和震动除了动画，甲方提出了在页面中加入声音和震动的需求。但是这些会涉及到各种手机的兼容性问题。（1代表支持，0代表不支持） 安卓机 苹果机 声音播放 1 1 震动 1 0 声音自动播放 1 0 声音叠加 1 0 (注意：iPhone上声音自动播放的问题可以借助微信jssdk在wx.ready的回调函数中实现)iphone只支持一次播放一个声音，不允许同时播放多个声音。总之iphone上对多媒体交互限制性比较严格， 具体有文献如下：https://www.ibm.com/developerworks/cn/web/wa-ioshtml5/index.html。 对此我们采用优雅兼容的方式，判断出用户的手机类型，对应使用不同的处理方式，只能尽量保证体验一致。 x5内核对用户http协议的代理问题,无法获取Android用户位置问题当前越来越多的网站使用了更安全的https协议，如果没有使用https协议的话微信（腾讯x5浏览器内核）会私自代理你的网络请求，导致无法获取用户位置等问题。（微信浏览器内核（QQ浏览器X5内核）在用户不知情情况下代理访问http页面）。而且下一步微信可能会效仿苹果（也是国际上的趋势）必须要求在其内使用https协议，否则网页会被列为不安全网页，甚至不允许访问。 设计时对文案长短和数字长短的考虑这是前端和设计师长久以来一直面对的问题了，在开发和设计时要对大数字和很长的文案有预估。较长的文案有折行和用省略号表示的情况出现，要有心理预期。对于非常大的数字，随后会写个模块封装一下万，千万，和亿的显示（关于阿拉伯数字和中文数字表达是一个很有趣的算法题）。 新型手机18：9比例的适配越来越多的手机使用18：9所谓的全面屏设计，导致在活动页面这种需要全屏铺满的页面中适配比较麻烦，当前使用了淘宝的amfe-flexible和构建阶段的插件px2rem.自动将px适配到相对单位rem，并能适应各种尺寸的设计图。具体如下：自适应布局：淘宝js包：12npm installl amfe-flexiblenpm install fis3-preprocessor-px2rem -g 12345678//fis-conffis.match('test.css', &#123; preprocessor: fis.plugin('px2rem',&#123; designWidth: 640 &#125;)&#125;)//index.jsimport flexible from 'amfe-flexible'; webpack 中使用 https://www.npmjs.com/package/px2rem-loader 微信授权和分享相关的接口调试这方面需要后台支持，基本思路就是用中转页面，或者接口重定向到]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式学习（转自github）]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2Fregex_base01%2F</url>
    <content type="text"><![CDATA[全文粘贴了learn-regex ## 翻译: English Spanish 中文版 日本語## 什么是正则表达式?&gt; 正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.“Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”.正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.我们使用以下正则表达式来验证一个用户名: 以上的正则表达式可以接受 john_doe, jo-hn_doe, john12_as.但不匹配Jo, 因为它包含了大写的字母而且太短了. 目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 号 2.3.3 ? 号 2.4 {} 号 2.5 (…) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 前后关联约束(前后预查) 4.1 ?=… 前置约束(存在) 4.2 ?!… 前置约束-排除 4.3 ?&lt;= … 后置约束-存在 4.4 ?&lt;!… 后置约束-排除 5. 标志 5.1 忽略大小写 (Case Insensitive) 5.2 全局搜索 (Global search) 5.3 多行修饰符 (Multiline) 额外补充 贡献 许可证 1. 基本匹配正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.例如: 一个正则表达式 the, 它表示一个规则: 由字母t开始,接着是h,再接着是e. "the" => The fat cat sat on the mat. 在线练习 正则表达式123匹配字符串123. 它逐个字符的与输入的正则表达式做比较. 正则表达式是大小写敏感的, 所以The不会匹配the. "The" => The fat cat sat on the mat. 在线练习 2. 元字符正则表达式主要依赖于元字符.元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍: 元字符 描述 . 句号匹配任意单个字符除了换行符. [ ] 字符种类. 匹配方括号内的任意字符. [^ ] 否定的字符种类. 匹配除了方括号里的任意字符 * 匹配&gt;=0个重复的在*号之前的字符. + 匹配&gt;=1个重复的+号前的字符. ? 标记?之前的字符为可选. {n,m} 匹配num个中括号之前的字符 (n &lt;= num &lt;= m). (xyz) 字符集, 匹配与 xyz 完全相等的字符串. &#124; 或运算符,匹配符号前或后的字符. &#92; 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \ &#124; ^ 从开始行开始匹配. $ 从末端开始匹配. 2.1 点运算符 ..是元字符中最简单的例子..匹配任意单个字符, 但不匹配换行符.例如, 表达式.ar匹配一个任意字符后面跟着是a和r的字符串. ".ar" => The car parked in the garage. 在线练习 2.2 字符集字符集也叫做字符类.方括号用来指定一个字符集.在方括号中使用连字符来指定字符集的范围.在方括号中的字符集不关心顺序.例如, 表达式[Tt]he 匹配 the 和 The. "[Tt]he" => The car parked in the garage. 在线练习 方括号的句号就表示句号.表达式 ar[.] 匹配 ar.字符串 "ar[.]" => A garage is a good place to park a car. 在线练习 2.2.1 否定字符集一般来说 ^ 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.例如, 表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符. "[^c]ar" => The car parked in the garage. 在线练习 2.3 重复次数后面跟着元字符 +, * or ? 的, 用来指定匹配子模式的次数.这些元字符在不同的情况下有着不同的意思. 2.3.1 * 号*号匹配 在*之前的字符出现大于等于0次.例如, 表达式 a* 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串. "[a-z]*" => The car parked in the garage #21. 在线练习 *字符和.字符搭配可以匹配所有的字符.*.*和表示匹配空格的符号\s连起来用, 如表达式\s*cat\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串. "\s*cat\s*" => The fat cat sat on the concatenation. 在线练习 2.3.2 + 号+号匹配+号之前的字符出现 &gt;=1 次个字符.例如表达式c.+t 匹配以首字母c开头以t结尾,中间跟着任意个字符的字符串. "c.+t" => The fat cat sat on the mat. 在线练习 2.3.3 ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选, 即出现 0 或 1 次.例如, 表达式 [T]?he 匹配字符串 he 和 The. "[T]he" => The car is parked in the garage. 在线练习 "[T]?he" => The car is parked in the garage. 在线练习 2.4 {} 号在正则表达式中 {} 是一个量词, 常用来一个或一组字符可以重复出现的次数.例如, 表达式 [0-9]{2,3} 匹配 2～3 位 0～9 的数字. "[0-9]{2,3}" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 我们可以省略第二个参数.例如, [0-9]{2,} 匹配至少两位 0~9 的数字. 如果逗号也省略掉则表示重复固定的次数.例如, [0-9]{3} 匹配3位数字 "[0-9]{2,}" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 "[0-9]{3}" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 2.5 (...) 特征标群特征标群是一组写在 (...) 中的子模式. 例如之前说的 {} 是用来表示前面一个字符出现指定次数. 但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab. 我们还可以在 () 中用或字符 | 表示或. 例如, (c|g|p)ar 匹配 car 或 gar 或 par. "(c|g|p)ar" => The car is parked in the garage. 在线练习 2.6 | 或运算符或运算符就表示或, 用作判断条件. 例如 (T|t)he|car 匹配 (T|t)he 或 car. "(T|t)he|car" => The car is parked in the garage. 在线练习 2.7 转码特殊字符反斜线 \ 在表达式中用于转码紧跟其后的字符. 用于指定 { } [ ] / \ + * . $ ^ | ? 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 \. 例如 . 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 . 则要写成 \. 以下这个例子 \.?是选择性匹配. "(f|c|m)at\.?" => The fat cat sat on the mat. 在线练习 2.8 锚点在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. ^ 指定开头, $ 指定结尾. 2.8.1 ^ 号^ 用来检查匹配的字符串是否在所匹配字符串的开头. 例如, 在 abc 中使用表达式 ^a 会得到结果 a. 但如果使用 ^b 将匹配不到任何结果. 因为在字符串 abc 中并不是以 b 开头. 例如, ^(T|t)he 匹配以 The 或 the 开头的字符串. "(T|t)he" => The car is parked in the garage. 在线练习 "^(T|t)he" => The car is parked in the garage. 在线练习 2.8.2 $ 号同理于 ^ 号, $ 号用来匹配字符是否是最后一个. 例如, (at\.)$ 匹配以 at. 结尾的字符串. "(at\.)" => The fat cat. sat. on the mat. 在线练习 "(at\.)$" => The fat cat. sat. on the mat. 在线练习 3. 简写字符集正则表达式提供一些常用的字符集简写. 如下: 简写 描述 . 除换行符外的所有字符 \w 匹配所有字母数字, 等同于 [a-zA-Z0-9_] \W 匹配所有非字母数字, 即符号, 等同于: [^\w] \d 匹配数字: [0-9] \D 匹配非数字: [^\d] \s 匹配所有空格字符, 等同于: [\t\n\f\r\p{Z}] \S 匹配所有非空格字符: [^\s] \f 匹配一个换页符 \n 匹配一个换行符 \r 匹配一个回车符 \t 匹配一个制表符 \v 匹配一个垂直制表符 \p 匹配 CR/LF (等同于 \r\n)，用来匹配 DOS 行终止符 4. 前后关联约束(前后预查)前置约束和后置约束都属于非捕获簇(用于匹配不在匹配列表中的格式).前置约束用于判断所匹配的格式是否在另一个确定的格式之后. 例如, 我们想要获得所有跟在 $ 符号后的数字, 我们可以使用正向向后约束 (?&lt;=\$)[0-9\.]*.这个表达式匹配 $ 开头, 之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次. 前后关联约束如下: 符号 描述 ?= 前置约束-存在 ?! 前置约束-排除 ?&lt;= 后置约束-存在 ?&lt;! 后置约束-排除 4.1 ?=... 前置约束(存在)?=... 前置约束(存在), 表示第一部分表达式必须跟在 ?=...定义的表达式之后. 返回结果只瞒住第一部分表达式.定义一个前置约束(存在)要使用 (). 在括号内部使用一个问号和等号: (?=...). 前置约束的内容写在括号中的等号后面.例如, 表达式 [T|t]he(?=\sfat) 匹配 The 和 the, 在括号中我们又定义了前置约束(存在) (?=\sfat) ,即 The 和 the 后面紧跟着 (空格)fat. "[T|t]he(?=\sfat)" => The fat cat sat on the mat. 在线练习 4.2 ?!... 前置约束-排除前置约束-排除 ?! 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式前置约束-排除 定义和 前置约束(存在) 一样, 区别就是 = 替换成 ! 也就是 (?!...). 表达式 [T|t]he(?!\sfat) 匹配 The 和 the, 且其后不跟着 (空格)fat. "[T|t]he(?!\sfat)" => The fat cat sat on the mat. 在线练习 4.3 ?&lt;= ... 后置约束-存在后置约束-存在 记作(?&lt;=...) 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.例如, 表达式 (?&lt;=[T|t]he\s)(fat|mat) 匹配 fat 和 mat, 且其前跟着 The 或 the. "(? 在线练习 4.4 ?&lt;!... 后置约束-排除后置约束-排除 记作 (?&lt;!...) 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.例如, 表达式 (?&lt;!(T|t)he\s)(cat) 匹配 cat, 且其前不跟着 The 或 the. "(?&lt;![T|t]he\s)(cat)" => The cat sat on cat. 在线练习 5. 标志标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.这些标志可以任意的组合使用, 它也是整个正则表达式的一部分. 标志 描述 i 忽略大小写. g 全局搜索. m 多行的: 锚点元字符 ^ $ 工作范围在每行的起始. 5.1 忽略大小写 (Case Insensitive)修饰语 i 用于忽略大小写.例如, 表达式 /The/gi 表示在全局搜索 The, 在后面的 i 将其条件修改为忽略大小写, 则变成搜索 the 和 The, g 表示全局搜索. "The" => The fat cat sat on the mat. 在线练习 "/The/gi" => The fat cat sat on the mat. 在线练习 5.2 全局搜索 (Global search)修饰符 g 常用语执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).例如, 表达式 /.(at)/g 表示搜索 任意字符(除了换行) + at, 并返回全部结果. "/.(at)/" => The fat cat sat on the mat. 在线练习 "/.(at)/g" => The fat cat sat on the mat. 在线练习 5.3 多行修饰符 (Multiline)多行修饰符 m 常用语执行一个多行匹配. 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 m. 例如, 表达式 /at(.)?$/gm 表示在待检测字符串每行的末尾搜索 at后跟一个或多个 . 的字符串, 并返回全部结果. "/.at(.)?$/" => The fat cat sat on the mat. 在线练习 "/.at(.)?$/gm" => The fat cat sat on the mat. 在线练习 贡献 报告问题 开放合并请求 传播此文档 直接和我联系 ziishaned@gmail.com 或 许可证MIT © Zeeshan Ahmed]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的mvvm（1）]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2Fvue_base01%2F</url>
    <content type="text"><![CDATA[通过vue框架的简单学习来了解js的mvvm思想。 mvvm雏形都在说jq的黄金时代已过，但是jq在当前很多项目中也仍在发挥着重要的作用。个人觉得jq+模板引擎+各种插件的开发模式是当下非常流行的mvvm的雏形。各种模板引擎充当view的角色，同样使用js的对象充当model，同样通过修改赋值给模板引擎的数据来实现view层的改变。（模板引擎的使用不在这里赘述，详情参见《新一代 javascript 模板引擎:artTemplate-3.0》）这套方法可以基本实现mvvm中的单向数据绑定（双向数据绑定择需要配合jq的事件监听，或其他复杂方法），jq在其中起到的作用只是简单的dom节点获取，然后把模板生成的html格式字符串再输出到指定位置，这种简单的dom操作甚至完全可以通过原生的js代替。而jq的插件多用来在view层进行更改，若是要配合数据输出的话只需简单的在html中套用模板引擎并稍加修改就可以。在小型项目，页面较少、表单较少、非SPA等情况下，这种开发方式具有高度的灵活性和便利性，学习成本非常低。当然随着前端代码的复杂性不断提升，ajax数据交互的更频繁，SPA更加流行等趋势，一套完整的、体系化的mvvm框架能帮助开发者更快，更舒适的开发。mvvm框架有很多，最知名的angular和react的大战持续了一段时间，但是angular2.0的断层兼容与react的jsx语法都有颠覆式的学习成本，国内大神的vue在2016年渐渐的积攒人气正在迎头赶上，而且和之前所说的jq+模板引擎的雏形开发方式相像处不少，通过对vue的学习可以较为系统的理解js的mvvm。 vue的安装安装Vue有很多方法，可以用npm或者webpack。但是我们现在的目标是尽快用起来，所以最简单的方法是直接在HTML代码中像引用jQuery一样引用Vue。可以直接使用CDN的地址，例如：1&lt;script src="https://unpkg.com/vue@2.0.1/dist/vue.js"&gt;&lt;/script&gt; vue和随后路由组件（vue-router），ajax请求组件（vue-resource），表单验证组件（vue-validator）等最好由自动化工具webpack来配合使用，自动化工具选择的灵活性是mvvm框架与jq+模板引擎无法比拟的地方，当然强大的webpack对组件式开发带来的便利性也是非常有利的。 vue的单向数据绑定用js的对象实现一个model：1234&#123; name:'Robot', age: 15&#125; 而view层的dom节点用类似于模板引擎的{ {name} }和 { {age} }来引用model的属性：1234&lt;div id="vm"&gt; &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt; &lt;p&gt;You are &#123;&#123; age &#125;&#125; years old!&lt;/p&gt;&lt;/div&gt; 最后一步是用Vue把两者关联起来。要特别注意的是，在&lt; head &gt;内部编写的JavaScript代码，需要用jQuery把MVVM的初始化代码推迟到页面加载完毕后执行，否则，直接在&lt; head &gt;内执行MVVM代码时，DOM节点尚未被浏览器加载，初始化将失败。正确的写法如下：12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;head&gt;&lt;!-- 引用jQuery --&gt;&lt;script src="/static/js/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 引用Vue --&gt;&lt;script src="/static/js/vue.js"&gt;&lt;/script&gt;&lt;script&gt;// 初始化代码:$(function () &#123; var vm = new Vue(&#123; el: '#vm', data: &#123; name: 'Robot', age: 15 &#125; &#125;); window.vm = vm;&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vm"&gt; &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt; &lt;p&gt;You are &#123;&#123; age &#125;&#125; years old!&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;html&gt; 我们创建一个VM的核心代码如下：1234567var vm = new Vue(&#123; el: '#vm', data: &#123; name: 'Robot', age: 15 &#125;&#125;); 其中，el指定了要把Model绑定到哪个DOM根节点上，语法和jQuery类似。这里的‘#vm’对应ID为vm的一个节点：123&lt;div id="vm"&gt; ...&lt;/div&gt; 该节点以及该节点内部，就是vue可以操作的view。Vue可以自动把Model的状态映射到View上，但是不能操作View范围之外的其他DOM节点。实际操作过程中若是页面不复杂可以类似于angular一样直接把body整个选中当做可操作的view。然后，data属性指定了Model，我们初始化了Model的两个属性name和age，在View内部的&lt; p &gt;节点上，可以直接用 name 引用Model的某个属性。用浏览器打开html，显示12Hello, Robot!You are 15 years old! 然后可以直接用js代码1window.vm.name = 'Bob' 来进行单向数据绑定操作，页面输出为12Hello, Bob!You are 15 years old! 原来的Hello, Robot!自动变成了Hello, Bob!。Vue作为MVVM框架会自动监听Model的任何变化，在Model数据变化时，更新View的显示。这种Model到View的绑定我们称为单向绑定。在Vue中，可以直接写 name 绑定某个属性。如果属性关联的是对象，还可以用多个.引用，例如，{ { address.zipcode } }。另一种单向绑定的方法是使用Vue的指令v-text，写法如下：1&lt;p&gt;Hello, &lt;span v-text="name"&gt;&lt;/span&gt;!&lt;/p&gt; 这种写法是把指令写在HTML节点的属性上，它会被Vue解析，该节点的文本内容会被绑定为Model的指定属性，注意不能再写双花括号。 vue的双向数据绑定 单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。有单向绑定，就有双向绑定。如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。什么情况下用户可以更新View呢？填写表单就是一个最直接的例子。当用户填写表单时，View的状态就被更新了，如果此时MVVM框架可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定，在浏览器中，当用户修改了表单的内容时，我们绑定的Model会自动更新。 在Vue中，使用双向绑定非常容易，我们仍然先创建一个VM实例：12345678var vm = new Vue(&#123; el: '#vm', data: &#123; email: '', name: '' &#125; &#125;); window.vm = vm; 然后，编写一个HTML FORM表单，并用v-model指令把某个&lt; input &gt;和Model的某个属性作双向绑定：1234&lt;form id="vm" action="#"&gt; &lt;p&gt;&lt;input v-model="email"&gt;&lt;/p&gt; &lt;p&gt;&lt;input v-model="name"&gt;&lt;/p&gt;&lt;/form&gt; 我们可以在表单中输入内容，然后在浏览器console中用window.vm.$data查看Model的内容，也可以用window.vm.name查看Model的name属性，它的值和FORM表单对应的&lt; input &gt;是一致的。如果在浏览器console中用JavaScript更新Model，例如，执行window.vm.name=’Bob’，表单对应的&lt; input &gt;内容就会立刻更新。 参照：廖雪峰的官方网站javascript教程部分]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的mvvm（2）]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2Fvue_base02%2F</url>
    <content type="text"><![CDATA[vue处理事件当用户提交表单时，传统的做法是响应onsubmit事件，用jQuery获取表单内容，检查输入是否有效，最后提交表单，或者用AJAX提交表单。现在，获取表单内容已经不需要了，因为双向绑定直接让我们获得了表单内容，并且获得了合适的数据类型。响应onsubmit事件也可以放到VM中。我们在&lt; form &gt;元素上使用指令：1&lt;form id="vm" v-on:submit.prevent="register"&gt; 其中，v-on:sumbit=”register”指令就会自动监听表单的submit事件，并调用register方法处理该事件。使用.prevent表示阻止事件冒泡，这样，浏览器不再处理FORM的submit事件。因为我们指定了事件处理函数是register，所以需要在创建VM时添加一个register函数：12345678910111213var vm = new Vue(&#123; el: '#vm', data: &#123; ... &#125;, methods: &#123; register: function () &#123; // 显示JSON格式的Model: alert(JSON.stringify(this.$data)); // TODO: AJAX POST... &#125; &#125;&#125;); 点击事件、鼠标经过事件等与其都类似。 模板循环判断等模板最重要和最常用的功能就是条件渲染和循环渲染列表，mvvm框架的view层也都提供了类似的用法： 条件渲染与常见的字符串模板不同，mvvm框架的条件循环是借助元素的指令完成的，所以通常会借助一个空标签template来完成，最终的渲染结果不包含此空标签：1234567891011121314151617&lt;div id="vm"&gt;&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $(function() &#123; var vm = new Vue(&#123; el: '#vm', data: &#123; ok: true &#125; &#125;) &#125;); &lt;/script&gt; 列表循环渲染列表循环的方式和条件循环类似，最好通过空标签template进行渲染：1234567891011121314151617181920&lt;ul id="vm"&gt; &lt;template v-for="item in items"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; &lt;script type="text/javascript"&gt; $(function() &#123; var vm = new Vue(&#123; el: '#vm', data: &#123; items: [ &#123; msg: 'Foo' &#125;, &#123; msg: 'Bar' &#125; ] &#125; &#125;) &#125;); &lt;/script&gt; 当然也可以直接把指令挂在需要循环的元素上，循环渲染。需要注意的是，Vue之所以能够监听Model状态的变化，是因为JavaScript语言本身提供了Proxy或者Object.observe()机制来监听对象状态的变化。但是，对于数组元素的赋值，却没有办法直接监听，因此，如果我们直接对数组元素赋值：123vm.items[0] = &#123; msg: 'New name',&#125;; 会导致Vue无法更新View。正确的方法是不要对数组元素赋值，而是更新：1vm.items[0].msg='New name'; vue插件的简单介绍vue-resource ajax请求插件可以直接通过script标签引入，或者其他自动化工具。1&lt;script src="https://cdn.jsdelivr.net/vue.resource/1.0.3/vue-resource.min.js"&gt;&lt;/script&gt; 我们给VM增加一个init()方法，读取后台发送的列表：12345678910111213141516171819202122232425var vm = new Vue(&#123; el: '#vm', data: &#123; title: 'TODO List', todos: [] &#125;, created: function () &#123; this.init(); &#125;, methods: &#123; init: function () &#123; var that = this; that.$http.get('/api/todos').then(function (resp) &#123; // 调用API成功时调用json()异步返回结果: resp.json().then(function (result) &#123; // 更新VM的todos: that.todos = result.todos; &#125;); &#125;, function (resp) &#123; // 调用API失败: alert('error'); &#125;); &#125; &#125;&#125;); jsonp示例：1234this.$http.jsonp(jsonpUrl,&#123;jsonpCallback:jsonpName&#125;).then(function(rep)&#123; rep=rep.body; console.log(rep);&#125;) 注意到创建VM时，created指定了当VM初始化成功后的回调函数，这样，init()方法会被自动调用。类似的，对于添加、修改、删除的操作，我们也需要往VM中添加对应的函数。以添加为例：1234567891011121314151617181920var vm = new Vue(&#123; ... methods: &#123; ... create: function (todo) &#123; var that = this; that.$resource('/api/todos').save(todo).then(function (resp) &#123; resp.json().then(function (result) &#123; that.todos.push(result); &#125;); &#125;, showError); &#125;, update: function (todo, prop, e) &#123; ... &#125;, remove: function (todo) &#123; ... &#125; &#125;&#125;); vue-router 2前后分离的开发方式把很多后端逻辑放到了前端来进行实现，spa单页面网站的流行，更是将路由和部分其他中间件交给了前端来实现，mvvm框架的流行很大一部分也是基于spa的兴起。vue拥有官方路由插件vue-router，用 Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js 时，我们就已经把组件组合成一个应用了，当你要把 vue-router 加进来，只需要配置组件和路由映射，然后告诉 vue-router 在哪里渲染它们。下面是个基本例子：1234567891011121314&lt;script src="https://cdn.bootcss.com/vue-router/2.0.0/vue-router.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031// 0. 如果使用模块化机制编程， 要调用 Vue.use(VueRouter)// 1. 定义（路由）组件。// 可以从其他文件 import 进来var Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;var Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点在讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。var router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能var app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了！ 总结 从几个例子我们可以看到，MVVM最大的优势是编写前端逻辑非常复杂的页面，尤其是需要大量DOM操作的逻辑，利用MVVM可以极大地简化前端页面的逻辑。但是MVVM不是万能的，它的目的是为了解决复杂的前端逻辑。对于以展示逻辑为主的页面，例如，新闻，博客、文档等，不能使用MVVM展示数据，因为这些页面需要被搜索引擎索引，而搜索引擎无法获取使用MVVM并通过API加载的数据。所以，需要SEO（Search Engine Optimization）的页面，不能使用MVVM展示数据。不需要SEO的页面，如果前端逻辑复杂，就适合使用MVVM展示数据，例如，工具类页面，复杂的表单页面，用户登录后才能操作的页面等等。]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fullscreen API：全屏操作]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2Ffullscreenjs%2F</url>
    <content type="text"><![CDATA[参考自《让你的页面全屏》 进入全屏方法：123456789101112//需要传入dom对象function launchFullscreen(element) &#123; if(element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if(element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if(element.msRequestFullscreen)&#123; element.msRequestFullscreen(); &#125; else if(element.webkitRequestFullscreen) &#123; element.webkitRequestFullScreen(); &#125;&#125; 全屏状态改变监听：12345678910$(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function() &#123; if (!document.fullscreenElement &amp;&amp; // alternative standard method !document.mozFullScreenElement &amp;&amp; !document.webkitFullscreenElement &amp;&amp; !document.msFullscreenElement) &#123; console.log('退出全屏'); &#125; else &#123; console.log('进入全屏'); &#125;&#125;);]]></content>
      <categories>
        <category>snippets</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js字符串操作]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2Fjs_stringHandle%2F</url>
    <content type="text"><![CDATA[一直想总结一篇js的字符串操作文档，之前有过笔记，但是都比较零散，而且es6的出现让操作字符串出现了一些新的方式，今天看到了《JavaScript 字符串实用常操纪要》这篇blog，感觉总结的比较全面、实用特此摘抄一下。我自己常用到的方法加了强调符号。 字符串截取1. substring()1xString.substring(start,end) substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。 举例：1234let str = 'www.jeffjade.com'console.log(str.substring(0,3)) // wwwconsole.log(str.substring(0)) //www.jeffjade.comconsole.log(str.substring(-2)) //www.jeffjade.com (传负值则视为0) 2. slice()1stringObject.slice(start, end) slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符。 举例：123456let str = 'www.jeffjade.com'console.log(str.slice(0, 3)) // wwwconsole.log(str.slice(-3, -1)) // coconsole.log(str.slice(1, -1)) // www.jeffjade.coconsole.log(str.slice(2, 1)) // '' (返回空字符串,start须小于end)console.log(str.slice(-3, 0)) // '' (返回空字符串,start须小于end) 3. substr()1stringObject.substr(start,length) substr()方法可在字符串中抽取从start下标开始的指定数目的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，则表示从字符串尾部开始算起 举例：12345let str = 'www.jeffjade.com'console.log(webStr.substr(1, 3)) // ww.console.log(webStr.substr(0)) // www.jeffjade.comconsole.log(webStr.substr(-3, 3)) // comconsole.log(webStr.substr(-1, 5)) // m (目标长度较大的话，以实际截取的长度为准) 4. split()1str.split([separator][, limit]) separator 指定用来分割字符串的字符（串）。separator 可以是一个字符串或正则表达式。 如果忽略 separator，则返回整个字符串的数组形式。如果 separator 是一个空字符串，则 str 将会把原字符串中每个字符的数组形式返回。 limit 一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。 举例：1234let str = 'www.jeffjade.com'str.split('.') // ["www", "jeffjade", "com"]str.split('.', 1) // ["www"]str.split('.').join('') // wwwjeffjadecom 原文作者对这个方法比较称道，我自己也很常用这个方法，splite()和join()配合使用是很常见的方式。 查找类方法1. indexOf() &amp; includes()1stringObject.indexOf(searchValue,fromIndex) indexOf()用来检索指定的字符串值在字符串中首次出现的位置。它可以接收两个参数，searchValue 表示要查找的子字符串，fromIndex 表示查找的开始位置，省略的话则从开始位置进行检索。 举例12345let str = 'www.jeffjade.com'console.log(str.indexOf('.')) // 3console.log(str.indexOf('.', 1)) // 3console.log(str.indexOf('.', 5)) // 12console.log(str.indexOf('.', 12)) // -1 虽然 indexOf()用来检索指定的字符串值在字符串中首次出现的位置 ，然而很多时候，使用它的场景在于判断字符串中是否存在指定的字符串；因此代码就会如此：123if (str.indexOf('yoursPecifiedStr') !== -1) &#123; // do something&#125; 要知道在这样的场景下，ES6 语言中的includes()就显得更优雅许多；includes() 方法用于判断一个字符串是否被包含在另一个字符串中，如果是返回true，否则返回false。1str.includes(searchString[, position]) searchString 将要搜寻的子字符串。position 可选。从当前字符串的哪个索引位置开始搜寻子字符串；默认为0。需要注意的是，includes() 是区分大小写的。 举例12345'Blue Whale'.includes('blue'); // returns false'乔峰乔布斯乔帮主'.includes('乔布斯'); // returns trueif (str.includes('yoursPecifiedStr')) &#123; // do something(这样写是不是更为人性化？Yeah，这是一个更趋向人性化的时代嘛)&#125; 2. lastIndexOf()1stringObject.lastIndexOf(searchValue,fromIndex) lastIndexOf()语法与indexOf()类似，它返回的是一个指定的子字符串值最后出现的位置，其检索顺序是从后向前。 举例12345let str = 'www.jeffjade.com'console.log(str.lastIndexOf('.')) // 12console.log(str.lastIndexOf('.', 1)) // -1console.log(str.lastIndexOf('.', 5)) // 3console.log(str.lastIndexOf('.', 12)) // 12 3.search()12stringObject.search(substr)stringObject.search(regexp) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1 举例1234let str = 'www.jeffjade.com'console.log(str.search('w')) // 0console.log(str.search(/j/g)) // 4console.log(str.search(/\./g)) // 3 3.match()12stringObject.match(substr)stringObject.match(regexp) match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。 举例1234let str = '#1a2b3c4d5e#';console.log(str.match('A')); //返回nullconsole.log(str.match('b')); //返回["b", index: 4, input: "#1a2b3c4d5e#"]console.log(str.match(/b/)); //返回["b", index: 4, input: "#1a2b3c4d5e#"] 如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。 123let str = '#1a2b3c4d5e#'console.log(str.match(/h/g)) //返回nullconsole.log(str.match(/\d/g)) //返回["1", "2", "3", "4", "5"] 其他方法1.replace()1stringObject.replace(regexp/substr,replacement) replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。 举例123let str = 'www.jeffjade.com'console.log(str.replace('w', 'W')) // Www.jeffjade.comconsole.log(str.replace(/w/, 'W')) // Www.jeffjade.com 如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。12let str = 'www.jeffjade.com'console.log(str.replace(/w/g, 'W')) // WWW.jeffjade.com 2.toLowerCase() &amp; toUpperCase()12stringObject.toLowerCase()stringObject.toUpperCase() toLowerCase()方法可以把字符串中的大写字母转换为小写，toUpperCase()方法可以把字符串中的小写字母转换为大写。 123let str = 'www.jeffjade.com'console.log(str.toLowerCase()) // www.jeffjade.comconsole.log(str.toUpperCase()) // WWW.JEFFJADE.COM 3.模板字符串这是es6的新特性，的确比较人性化，感觉是借鉴了类似于python等语言的理念 12345678function ncieFunc() &#123; return "四海无人对夕阳";&#125;var niceMan = "陈寅恪";var jadeTalk = `一生负气成今日 \n $&#123;ncieFunc()&#125; ,语出 $&#123;niceMan&#125; 的《忆故居》。`console.log(jadeTalk) 运行结果如下： 一生负气成今日四海无人对夕阳 ,语出 陈寅恪 的《忆故居》。 配合使用很多字符串的操作可以自定义工具函数来进行使用，lodash和jquery中提供了很多，这里摘抄原blog的一些使用。 1.字符串反转123String.prototype.reverse = function () &#123; return this.split('').reverse().join('')&#125; 2.去除空白行123String.prototype.removeBlankLines = function () &#123; return this.replace(/(\n[\s\t]*\r*\n)/g, '\n').replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, '')&#125; 去除字符串两端的空格可以用原生方法trim() 3.转化为二维数组12345678910111213141516171819String.prototype.removeBlankLines = function () &#123; return this.replace(/(\n[\s\t]*\r*\n)/g, '\n').replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, '')&#125;String.prototype.strTo2dArr = function(firstSplit, secondSplit)&#123; var contentStr = this.removeBlankLines(), contentStrArr = contentStr.split(firstSplit), resultArr = contentStrArr.map((element) =&gt; &#123; return element.split(secondSplit) &#125;) return resultArr&#125;var str = `渺渺钟声出远方,依依林影万鸦藏。一生负气成今日,四海无人对夕阳。破碎山河迎胜利,残馀岁月送凄凉。松门松菊何年梦,且认他乡作故乡。`console.log(str.strTo2dArr('\n', ',')) 运行结果为 [ [ ‘渺渺钟声出远方’, ‘依依林影万鸦藏。’ ],[ ‘一生负气成今日’, ‘四海无人对夕阳。’ ],[ ‘破碎山河迎胜利’, ‘残馀岁月送凄凉。’ ],[ ‘松门松菊何年梦’, ‘且认他乡作故乡。’ ] ] 直接转化为数组用split]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《移动网页设计与开发html5+css3+javascript》读书笔记]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2FreadingNotes1%2F</url>
    <content type="text"><![CDATA[《移动网页设计与开发html5+css3+javascript》一书写于2013年，在前端书籍中还算比较新的一本，当时html5，智能手机已经兴起，书中介绍的许多新技术在当今有一些已经是很普及的技术(css媒体查询，svg，canvas等)，还有很多技术因为国情还需兼容ie低版本和所谓的“手机上的ie”——腾讯的“x5内核”，所以没能普及（弹性盒子，web storage，视频音频基本API等）。书中还有部分前沿性的概念直到现在浏览器还没有实现其功能（原生web组件化，复杂的设备API）。 flexbox弹性盒子布局flexbox布局技术已经很成熟了，但是因为之前微信采用的x5内核很长一段时间没有支持，导致使用的人并不多，知名的阮一峰的blog已经对flexbox布局方式做了详细的解释。这里结合书中58页内容和blog一起总结一下，简单记录作为备忘，对没看过的人的作为一个简单了解。 1.使用flexbox在css中用display把元素设置为弹性盒子。1234567.box&#123; display: flex;&#125;/*或者设置为行内元素*/.box&#123; display: inline-flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 2.基本概念 上图已经很好的体现了flexbox的基本概念123456main axis =》水平的主轴 x轴cross axis =》垂直的交叉轴 y轴main start =》主轴的开始位置（与边框的交叉点）cross end =》主轴的结束位置（与边框的交叉点）cross start =》交叉轴的开始位置cross end =》交叉轴的结束位置 3.属性设置及例子 flex-direction 主轴方向 x轴方向，甚至能和y轴互换 flex-wrap 换行方式 flex-flow 流动方式（上两个的简写方式） justify-content 主轴对齐方式 align-items 交叉轴对齐方式 align-content 多根轴线的对齐方式 原文中详尽的解释了这些属性的作用，我把这种新的布局方法实现用positon和float布局的方式做个对应。 水平排列1234567.fBox &#123; overflow: hidden;&#125;.fItem &#123; float: left;&#125; 123456.fBox &#123; display:flex; flex-flow:row wrap;&#125;.fItem &#123;&#125; 水平居右反排列1234567.fBox &#123; overflow: hidden;&#125;.fItem &#123; float: right;&#125; 123456.fBox &#123; display:flex; flex-flow:row-reverse wrap;&#125;.fItem &#123;&#125; 水平居右正排列12345678910.fBox &#123; overflow: hidden;&#125;.wrap&#123; float: right; overflow: hidden;&#125;.fItem &#123; float: left;&#125; 123456.fBox &#123; display:flex; justify-content:flex-end;&#125;.fItem &#123;&#125; 水平居中1旧的方式使用定位和负边距居中，或者设置为blog利用margin:auto居中,比较繁琐 123456.fBox &#123; display:flex; justify-content:center;&#125;.fItem &#123;&#125; 导航常用的设置：等距水平排列1旧的方式需要使用浮动和宽度计算实现，比较繁琐 123456.fBox &#123; display:flex; justify-content:space-around;&#125;.fItem &#123;&#125; 可以看到弹性盒子可以通过简单的属性配置就能代替float属性的绝大多数使用情况，而且不用引入伪类来清除浮动，或者引用overflow:hidden这种后患无穷的清浮动方式。弹性盒子布局的强大之处除了在水平方向的代替float方案，更强大的是在垂直方向的使用。很大程度上大体了position的使用。 全部子元素靠下排列12345678910111213.fBox &#123; position: relative;&#125;.wrap &#123; overflow: hidden; position: absolute; bottom: 0;&#125;.fItem &#123; float: left;&#125; 1234567.fBox &#123; display:flex; justify-content:flex-start; align-items:flex-end;&#125;.fItem &#123;&#125; 水平垂直居中1这是经典面试题，各种各样的方法和奇技淫巧可以实现 1234567.fBox &#123; display:flex; justify-content:center; align-items:center;&#125;.fItem &#123;&#125; 子元素属性及特殊用法弹性盒子之所以称之为“弹性”不仅仅是因为上述的几种简化了的布局的方式，更是因为在设置为display:flex后的元素的子元素上可以设置更为“弹性的方法” order 子元素排序 flex-grow 子元素弹性放大 flex-shrink 子元素弹性缩小 flex-basis 子元素宽度 flex 是flex-basis，flex-grow，flex-shrink的简写方式 align-self 设置子元素独特的align-items 上述方法在blog上有详细的描述。但是除了可以预料到的order属性和align-self外（这两个属性非常的强大，在布局中对特殊元素的处理会起很大的作用），真正所谓的弹性属性flex却缺少使用场景，原因下面阐述。 关于flexbox和响应式网站要不要响应式书中对弹性盒子布局的描述主要是为了网格布局和响应式网站做铺垫。很明显flex属性在响应式网站开发中会发挥巨大作用。最近的消息是全球最流行的web前端ui框架bootstrap也在新版本中放弃了传统的布局方式，全面使用了flexbox布局。更令国内开发者鼓舞的消息是腾讯x5内核也在今年的新版本中大大兼容了flexbox。而在全球范围内flexbox的兼容性也不用多有顾虑can I use但是响应式网站的根本问题是不适合定制化的制作，更适合模板网站的推广。像网站后台界面、blog的皮肤等场景，只需简单且固定的布局方式，无需复杂的展现方式是非常适合响应式开发的。但是当复杂的定制化需求时，当前国内网站开发的工作流是，专门的ui设计人员，专门的web前端人员和服务器端的人员这种配合开发方式。响应式开发对于ui设计的要求太高，而且前端开发并没有提高很大的开发效率，一样要写很多的媒体查询断点。而网站天然具有的界面易变性导致当需求有变动时，响应式网站很难改动。所以响应式网站在实际开发中并不多做考虑。但是flexbox那些可以代替定位和浮动的便利性功能在移动端可以放心的使用了，这也是flexbox布局最大的作用。 什么时候不用flexbox使用了flexbox后并不是要完全舍弃传统的position和float，而是让他们回归到他们原本在创立之初时就本应使用的地方——脱离文档流操作即z轴布局。可以说flexbox提供了较为完备的x轴、y轴解决方案，而当布局需要在z轴方向有布局要求时，使用position和float才是最合适的方式。 web组件书中175页开始对web组件的描述做了展望，提到了模板，样式封装，自定义元素，shadow DOM四个概念。不知道写书时react是否已经出现，但是react框架和近来很火的vue是这四个概念完整的体现。传统的前端代码组件方式为html文件，css文件夹，js文件夹，资源文件夹，当前端项目很小时，代码复用没有很高的要求，这样可以很好的配合后台的mvc架构。而如今前后分离的开发方式是主流，spa大行其道，前端功能越来越复杂，甚至包括要处理路由等功能。这种情况下，组件化的开发方式更能提高代码的复用率，而且以组件为单位维护复杂的网页更合理简便。 模板书中描述的模板的使用是在html底层来解决，而当前的开发方式用到的模板还是在js中实现的，js模板引擎有很多（这里就不分在后台还是前端使用了），ejs、jade、doT、artTemplate等，配合文章中提到的在div内部封装style标签来整合样式能基本完成简单的web组件化封装。而react中的jsx和其他现代化框架中的模板配合前端自动化工具的实现才更符合书中提到的web组件化的封装形态。 样式封装和自定义元素css预处理器less和sass提供了css编程的效果，也打下样式封装的基础。自定义元素也只能通过js的预处理才能完整的实现。之前这种预处理过程基本都是由开发者的ide或者一些其他语言的脚本工具来实现，所以应用并没有非常的广泛。而nodejs的发展让web前端开发带来了新的活力。nodejs开发之初是让js跑在服务器中，让jser更加的渗透到全栈领域，但是nodejs真正影响巨大的是通过制作前端工具来改变前端的开发。grunt，gulp，webpack等前端自动化构建工具的诞生彻底颠覆了传统的前端开发流程，这些工具利用node预先编译的形式完成了web组件在开发形式上的道路。同时也推动了很多前端mv*框架的诞生。2017年最火的三个前端框架肯定是angular，react，vue无疑，中小型项目选型又可以放弃angular这种臃肿的解决方案，vue和react都支持组件化开发（angular也有组件化解决方案），特别是react初始就采用的jsx语法（vue在2.0版本也开始支持jsx），完美的封装了web组件，这里又得提到阮一峰的blog罗列了react开发用到的技术栈。react和vue的开发又可以展开说很多这里就不做赘述了。 shadow DOMshadow DOM的概念非常的好，是解决web组件化封装和性能的一种很好的方案，但是现代前端框架对dom性能的解决方案是Virtual DOM。这两种概念容易混淆。 Virtual DOM不是DOM，只是DOM的一种（经过优化的）映射，JS代码操作Virtual DOM获得更好的渲染性能，因为直接操作DOM额外开销太大。 Shadow DOM是指浏览器的一种能力，它允许在文档（document）渲染时插入一棵DOM元素子树，但是这棵子树不在主DOM树中。 二者的形态都是dom的一种映射， Virtual DOM是为了避免dom操作浪费性能用js模拟dom的解决方案，而Shadow DOM是html dom中利用特殊声明放置的一层无法用通常意义上的js选择器和css选择器来获取的dom，可能因为兼容性问题和操作的不便利性没有被其他框架所采用来映射dom操作和组件化封装。 总结下面对书中的提到四个概念和现代前端框架的解决方案作一个简单的对照： 模板 =》各式的template，jsx 样式封装 =》webpack 等自动化工具预处理 自定义元素 =》webpack 等自动化工具预处理 shadow DOM =》没有被采用，封装和性能方案被webpack 等自动化工具预处理与Virtual DOM代替。 虽然html5并没有从底层上有好的web组件化解决方案，但是以上提到的现代化的工具和框架已经用另一种方式实现了书中展望的web组件化，让开发者已经享受到了web组件化的便利性。 html5图片解决方案（svg图片和canvas）在移动优先为主的开发模式下，位图的能伸缩不变形的优势显的越来越重要，svg和canvas是矢量图在web上的两种最常见的解决方式，书中123页谈了svg格式和canvas格式的选择，总而就是svg更利于编辑，canvas性能更有优势。svg有很大的便利性和定制性，首先常见的位图设计工具ai和sketch等都可以导出svg，这对当前设计+前端+后台的web开发方式可以基本照搬使用，而且因为保留了基本的dom结构，也可以对其进行简单的js操作和css操作。但是这种看起来美好的格式却因为位图本身无法简便的制作高光阴影等效果，色彩较为单一等缺点一直无法得到重用。当前移动端图片适配还是通过大图片（@2、@3等）通过等比例压缩来保持清晰度和不同尺寸的适配。反而canvas的使用情况较多，canvas可以在浏览器端简单的处理图片（裁切，加滤镜，压缩等），而且因为其高性能性，复用程度高，定制化需求的低的一些模板图表，简单动画等都采用了canvas技术。canvas在html5游戏中也起到了非常重要的作用，较多html5游戏引擎都是基于canvas和webgl技术来实现的。canvas技术在前端圈火爆了一阵，似乎很多人都在学用canvas画一些简单的图画，但是其实复杂绘图和动画制作这种功能并不适合用代码来实现，更多的是用软件工具来进行所见即所得的编辑。复杂的canvas使用就不在这里详细阐述了，总之canvas在前端的使用更多是配合一些图形算法来进行图像的简单操作，html5的图片适应问题仍旧没有很完美的解决方案。 html5多媒体终究会是网络多媒体时代坐着写书时flash仍在web上有着很大的一席之地，但是到今天，flash已经彻底被主流所舍弃，国外大多的视频网站都放弃了flash，国内的视频也在今年逐渐的转型。多媒体+交互其实是网站的终极形态，苹果官网和一些很注重设计元素的网站，很多都用一个大的视频当做了网站的banner，今年很多的非常热的营销h5也逐渐加入了多媒体与用户交互的元素。可以预见，当运营商基础设施逐渐好时，人们的网速都达到一定程度时网站必将会产生分化，大多不注重有阅读元素的网站终究转换为视频+交互的网站，直播和小视频的愈演愈热就是直接的证明。 常见api分析HTML5视频的那些事儿一文中详细解释了视频相关的问题：总结就是 兼容选mp4格式，没有定制化需求 使用jwplayer等第三方播放软件（最近很火的是b站开源的flv.js是一个flv格式解决方案，可以多加关注），有定制化需求的看api：html5提供的多媒体api不算丰富只能说够用，大体常用的只有播放，暂停，进度，缓存等，列一个总目录： 属性列表 方法列表 事件列表 书中则阐述了进度条设置和播放暂停的实例可以作为对照。推荐两篇blog，对常见video和audio的使用做了很好的实践HTML5中使用js控制audio标签的方法使用 HTML5 音频和视频 总结html5多媒体更深层次的使用需要对视频和音频的底层进行了解，而且html5对视频仅仅是提供够用的api还是满足不了一些更复杂的交互要求，如广告插入，视频深层交互等功能。这也是当前很多公司没有放弃flash的原因。 设备APIweb storage设备API中用到的最多的就是web storage，书中101页开始简单描述了web storage的使用，作为代替cookie成为浏览器储存的方案web storage的使用很便捷： .setItem( key, value) 存储 .getItem(key) 提取 .removeItem(key) 删除 .clear() 全部清除 若是排除ie8的兼容考虑，浏览器的离线缓存方案完全可以用local storage来实现，而页面间的通信则可以使用local storage和session storage实现。书中这张的最后也提到了更现代化的IndexedDB——浏览器端数据库可以作为储备了解。 其他设备API更多的api开放是html5变得强大的根本，很多html5的设备api的使用大大提高了网页和用户的交互方式，如摄像头、麦克风、定位、方向、震动等等，书中做了简单的阐述和事例，当用到的这些api的时候可以查阅来做启发。看到和想到的几个利用新设备api很好的交互方式，有待实践： 利用方向api+3d贴图使做一些3d动画交互效果 地理定位API的地图和ar交互 利用网络信息api检测用户网络条件来进行不同的加载处理 这些强大的api和美好的想法要想实现主要受制于两点：浏览器厂商的分裂api导致的兼容问题，浏览器本身的性能问题。希望随着时间的推移这两点会有改观。 总结《移动网页设计与开发html5+css3+javascript》一书并不是一本入门书籍，更不像是一本工具书籍。全书只有不到200页，只是作者在2013年时对html5，css3，es5比XHTML，css2.0，es3新增了哪些主要的新功能并做了一些简单的实例和讲解。2016年看了这本书后我又结合我认为的当前比较热门主流的技术做了一些摘录和总结，并加了一些自己的观点拼凑出了此篇笔记。当然此书也有盲点，对于很重要的css3能实现的2d，3d动画效果只是一笔带过；websocket网络长链接这种大家很看好的技术也没有直接讲解；2013年es6（js2015）还未定稿，对最近的es6语法并没有过多的讲解而且全书对于js方面讲解本身就不多。正好下一篇对《javascript高级程序设计》读书笔记可以更侧重的讲js部分。]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>js h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前后端跨域联调总结]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2Fcors_base1%2F</url>
    <content type="text"><![CDATA[业务情景pc端和移动端双网页，需要兼容ie8，前后完全分离，页面与接口完全跨域，有post请求。 跨域解决方案总结使用了2号方案 1. CORScors跨域解决方案是当前前端最为通用的解决方案之一,可以说除了无法支持ie8，ie9，携带cookie略有限制之外没有别的缺点。配置过程网上也有详细的介绍较为简单 服务端配置 响应头添加： 12Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Origin: http://www.yourspacename.com/* 若要携带cookie则继续增加 12Access-Control-Allow-Credentials:trueAccess-Control-Allow-Headers:withCredentials 允许带 cookie 时，Access-Control-Allow-Origin 字段值不可以设置为 * 前端配置 正常使用ajax请求即可，若是需要携带cookie需要设置withCredentials: true,jq为添加配置： 123xhrFields: &#123; withCredentials: true,&#125; 注意这个属性不支持ie10及更早版本ie 2. CORS+XDomainRequest为了兼容ie8/ie9，使用Cross-Domain AJAX for IE8 and IE9，项目中有明确介绍如何配合jq使用，方案有几点值得注意： 无法设置请求头中的自定义字段,即只能使用简单请求 无法携带 cookie post请求只能contentType必须设置为text/plain,传递参数为一组json格式的字符串 只能是异步请求 ie8和ie9无法携带Referer 具体配置如下： 服务端配置 与CORS配置相同，但是post请求需要注意contentType为text/plain时php无法用$POST拿到传参，需要使用超全局变量$GLOBALS拿到参数 前端配置 123456789101112131415// GET$.getJSON('http://jsonmoon.jsapp.us/').done(function(data) &#123; console.log(data.name.first);&#125;);// POST$.ajax(&#123; url: 'http://frozen-woodland-5503.herokuapp.com/cors.json', data: 'this is data being posted to the server', contentType: 'text/plain', type: 'POST', dataType: 'json'&#125;).done(function(data) &#123; console.log(data.name.last);&#125;); 3. jsonp如果跨域只有get请求的话使用jsonp是最好的解决方案。 服务端配置 12$callback = isset( $_GET[ 'callback' ] ) ? $_GET[ 'callback' ] : 'callback';echo $callback . '(' . json_encode( $data ) . ')'; 既使用callback参数包装执行。 前端设置 在jquery中设置dataType为jsonp即可，其他与get请求设置基本相同，可设置指定的callback名字配合缓存。 12345678$.ajax(&#123; url: "http://ajax.yoursite.com/api.php", dataType: "jsonp", jsonpCallback:"jsonpName", success: function( json )&#123; alert( json ); &#125;&#125;); 4. document.domain+iframe&amp;&amp;window.name+iframe&amp;&amp;postMessage+iframe这类使用iframe传递信息的跨域方式解决方式大同小异， 都是在应用页面中嵌入（可以动态生成）一个指向空页面（about:blank）的iframe。 操作iframe，动态把post数据在iframe中生成一个表单,提交。 把表单的返回数据传递回应用页面。（若设置document.domain父子域，则可以直接获取iframe内容，若完全跨域使用window.name和postMessage传递） 销毁iframe 服务端配置 以window.name比较通用的方式为例，服务端返回的数据需要特殊处理，不再返回json，需要返回类似格式 1&lt;script&gt;window.name=&apos;&#123;需要的json字符串&#125;&apos;&lt;\/script&gt; 前端配置 前端处理比较多，上面已经讲了大概逻辑，还要涉及到处理兼容的问题。网上找到了一个封装好的函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function postJSONP(url, data, fn) &#123; var _doc = document,form = _doc.createElement("form"), iframeState,key,input,iframe,iframeName = "ifr" + Math.random().toString(16).slice(-6); //创建表单数据 if (!!data) &#123; for(key in data) &#123; input = _doc.createElement("input"); input.type = "hidden"; input.name = key; input.value = data[key]; form.appendChild(input); &#125; &#125; form.action = url; form.target = iframeName; form.method = "post"; _doc.body.appendChild(form); try &#123; iframe = _doc.createElement('&lt;iframe name="'+iframeName+'"&gt;');//兼容IE6、7 &#125; catch (e) &#123; iframe = _doc.createElement('iframe'); iframe.name = iframeName; &#125; iframe.style.display = "none"; iframe.attachEvent ? iframe.attachEvent("onload", fulfil) :(iframe.onload = fulfil);//事件处理 _doc.body.appendChild(iframe); form.submit();//表单提交 iframeState = 0;//框架状态记录 function fulfil()&#123; if(iframeState === 0)&#123; iframeState = 1; iframe.removeAttribute('name');//解决IE10+获取不到window.name的问题 iframe.contentWindow.location.replace("about:blank"); &#125;else if(iframeState === 1)&#123; iframeState = null; var json,arr,str = iframe.contentWindow.name; console.info(str); try&#123; json = window.JSON ? JSON.parse(str) : new Function("return " + str)(); &#125;catch(e)&#123; json = &#123;error:1&#125;; &#125; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); _doc.body.removeChild(iframe); _doc.body.removeChild(form); //执行回调方法 if(typeof fn === "function")&#123; fn(json); &#125;else if(arr = url.match(/[&amp;?]callback=([^&amp;#]+)/))&#123; typeof window[arr[1]] === 'function' &amp;&amp; fn(json); &#125; &#125; &#125; &#125; 使用时直接调用： 123postJSONP("http://libo.sina.com.cn:3000/t_post1",postData,function(data)&#123; console.log(data);&#125;); iframe方式实现跨域虽然貌似有良好的兼容性，但是配置和调试都非常的麻烦，而且不确定因素有很多，不是可靠的跨域实现方式。 关于cookie跨域携带cookie传递在跨域时兼容问题比较多， 使用CORS跨域传递cookie无法兼容ie，而且会让接口跨域无法设置通配符，在移动网站开发中可以使用，pc站无法使用。 天猫之前的方案是淘宝单独出一个接口使用jsonp获取cookie，post提交则直接把cookie内容写在post的body中直接提交。 使用iframe进行post提交可以跨域，但调试和配置比较复杂。 出于安全考虑敏感信息尽量不要放在cookie中。当使用post进行跨域提交时需要使用jwt等手段对敏感信息进行加密。 用到的js插件123456├── Base64.js├── jQuery-ajaxTransport-XDomainRequest.js├── jquery-1.11.1.min.js├── jquery.placeholder.js├── md5.js└── sweetalert.min.js 其他兼容坑 ie8，9无法传递Referer【服务端关闭对ie的Referer验证】 ie下用插件设置placeholder less编译时无法解析”/9”hack写法. 在es6转为es5时默认严格模式，一些写法ie11下会报错，用ts工具编译时需增加配置项：noImplicitUseStrict: true。 参考引用 解决ajax jsonp跨域请求时cookie的问题 Cross-Domain AJAX for IE8 and IE9 Check if user is using IE with jQuery JavaScript判断IE各版本最完美解决方案 关于 CORS —— 小船翻在了 IE8 的小沟沟里 js实现跨域(jsonp, iframe+window.name, iframe+window.domain, iframe+window.postMessage) 其他markdown表格制作网站（墙外）http://www.tablesgenerator.com/markdown_tables# id 跨域方案 get请求 post请求 兼容ie8 复杂请求 携带cookie 父子域名 完全跨域 配置复杂度 调试友好度 安全性 1 CORS √ √ X √ √* √ √ 2 5 5 2* CORS+xdomain √ √ √ X X √ √ 4 4 3 3 jsonp √ X √ X √ √ √ 1 3 2 4 document.domain+iframe √ √ √ X √ √ X 5 0 2 5 window.name+iframe √ √ √ X √ √ √ 5+ 0 2]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6和es7探查]]></title>
    <url>%2F2018%2F07%2F09%2FFE%2Fes6_es7_base1%2F</url>
    <content type="text"><![CDATA[读了《ECMAScript 6 入门》,主要是想谈非常吸引我的两个功能：async和Decorator,期间会涉及到es6的class相关功能。 终于等来了async写前端的大多数项目遭遇异步回调地域的情况较少，async主要是解决了nodejs的痛点。从promise到Generator,js终于等来了异步的终结解决方式，就是同步。。。为什么这么说呢，因为： async写法基本和同步写法一样，无非是加了关键字 用async写代码很容易让js丧失异步高性能的优势 类同步的写法123456var async ReadFile = async function () &#123; var f1 = await readFile('/etc/fstab'); console.log(f1.toString()); var f2 = await readFile('/etc/shells'); console.log(f2.toString());&#125;; 只需要在外层函数作用域前加async关键词，作用域内异步执行函数加await关键词，就可以像写同步写法一样写异步了。于是出现了在模块全局内直接用一个加了async关键字的立即执行匿名函数包裹整个模块的简单粗暴写法：1234567(async ()=&gt;&#123; var f1 = await readFile('/etc/fstab'); console.log(f1.toString()); var f2 = await readFile('/etc/shells'); console.log(f2.toString()); //other code...&#125;)(); 而async函数甚至可以“滥用”，直接给一个非异步执行的函数前加依然是有效的,因为 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 所以有了async你可以完全忘记node是一门四处是异步的语言。 容易造成性能损失nodejs推广最重要的特点之一就是“基于单线程异步的高并发性能io操作”，异步是node刻在血液里的特点，四处异步让coder很容易思考在哪里需要并发，哪里需要继发，保证了cpu性能近少浪费。但是async的到来让异步不在明显，有时无需继发的情况很容易让coder忽略写成同步执行。 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 错误捕捉如果非说async有什么缺点的话，错误捕捉可能算一个。因为包装了promise，如果promise出现了reject就会报错。只能用try{}catch(){}来进行容错处理。 目前node版本大于7.6的都原生支持了async,可以愉快的使用了。 被angular看重的decorator前段时间的av大战，a吐槽v一点就是v没有技术贡献，虽然说法偏颇，但是angular的确是很敢于在js上搞大新闻的。新angular（2.x开始的版本）中大量使用了es7新语法decorator. 是否写面向对象的js在刚接触js的时候面向对象是很困惑的东西，对于部分前端开发者来说其实写基于面向对象写法的js可能是不必要的。js的函数具有高度灵活性，开发者完全可以通过高级函数的特性完成大多数需要面向对象写法的功能。但是高度灵活性带来的问题就是多人配合开发的时候很难统一规范和风格，java之所以经久不衰其中之一的原因也可能是传统面向对象的固定甚至说死板的写法能够束缚所有开发者的编码风格，让开发的沟通成本减少。在当前js承担越来越多的工作，一个js项目需要多人配合，需要更高的代码复用率的趋势下，以往js开发者抵触面向对象的写法的心理逐渐减弱。es6正式引入class语法糖也是官方对面向对象写法的推动，甚至还有微软typescript等让js变的越来越像java的东西不断出现，js新的时代已经来临。 使用装饰器只能装饰类、类的方法、类的属性。修饰函数的参数在不同情况下代表的意义也不同。首先定义一个修饰函数作为显示：123456function showTest(target, name, descriptor) &#123; console.log(target); console.log(name); console.log(descriptor); console.log("***");&#125; 然后简单写一个类，测试修饰函数参数的不同表现1234567891011@showTestclass Test &#123; @showTest outName = 1; @showTest main() &#123; // @showTest this.inName = 2 &#125;&#125;let test = new Test(); 这里使用的是typescript转译工具把es7转换为es5。首先发现不能修饰方法里命名的属性，会报错。注释掉引起错误的代码后控制台输出为(chrome 60)：分析如下 装饰函数第1次执行为装饰类的属性，target属性指向类的实例，name指向属性的key，descriptor是undefined 装饰函数第2次执行为装饰类的方法，target属性指向类的实例，name指向方法的key，descriptor调用了Object.defineProperty() 装饰函数第3次执行为装饰类，target属性指向类本身，name是undefined，descriptor是undefined 注意：在修饰器修饰类时target指向类本身，直接给target增加属性只会给类增加静态属性，实例无法获取，要增添动态属性和方法应给给target.prototype添加，并且增加的方法不应该使用箭头函数。123456function showTest(target, name, descriptor) &#123; target.text1="静态属性实例无法获取"; target.prototype.text="动态属性"; target.prototype.showText=function()&#123; console.log("不用箭头函数的动态方法");&#125; 为了优雅decorator是一个es7针对class出的语法糖，解决的主要问题是优雅。书中下面代码：123456789101112131415@Component(&#123; tag: 'my-component', styleUrl: 'my-component.scss'&#125;)export class MyComponent &#123; @Prop() first: string; @Prop() last: string; @State() isVisible: boolean = true; render() &#123; return ( &lt;p&gt;Hello, my name is &#123;this.first&#125; &#123;this.last&#125;&lt;/p&gt; ); &#125;&#125; 语义明确，条例清晰。在写类的时候可以将一些常用的公共逻辑从类中抽离出来(如工具和指令)，让类一些功能更语义化。 装饰器和多重继承es6引入了class关键字，把之前js基于原型链继承的方式包装成为了类似java等传统意义上的面向对象的语言的继承方式。但其本质仍是基于原型链的继承方式，所以继承仍非常灵活，可以用mixin实现多重继承。decorator可以优雅的实现mixin。常用的类的混合： 部署一个通用脚本mixins.js，将 Mixin 写成一个修饰器。12345export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125; 然后，就可以使用上面这个修饰器，为类“混入”各种方法。1234567891011import &#123; mixins &#125; from './mixins';const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // "foo" 总结async和Decorator是两个非常超前的js功能，没有获得node和浏览器的广泛支持，甚至Decorator当前只能通过babel和typescript等转换工具来使用。这两个功能并没有给js带来什么功能上非常大的改变，只是让开发者更能优雅的写代码，可以说这两个功能并不是刚需。但是，这两个功能的确是js开发者非常期待的两个功能，尤其是async，可以让node的书写大大提高体验。虽然js并不是一门很年轻的语言，但近年来发力集采其他语言的优点，新加入的功能在python和C#等语言中都能找到熟悉的影子，随着语法和社区的逐渐壮大，越来越多的开发者一定会被js独特的魅力所吸引。]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django 初学(四)setting.py文件说明]]></title>
    <url>%2F2017%2F03%2F12%2Fpython%2Fdjango_base04%2F</url>
    <content type="text"><![CDATA[直接上自己的配置文件了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132"""Django settings for my_blog project.Generated by 'django-admin startproject' using Django 1.9.4.For more information on this file, seehttps://docs.djangoproject.com/en/1.9/topics/settings/For the full list of settings and their values, seehttps://docs.djangoproject.com/en/1.9/ref/settings/"""import os# Build paths inside the project like this: os.path.join(BASE_DIR, ...)# 项目根目录BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/1.9/howto/deployment/checklist/# SECURITY WARNING: keep the secret key used in production secret!# 项目安全码SECRET_KEY = '#t1oh^9leqfm44gpfn1ty0m31_qmn@y!nw+(p95)+_jvf)ep_z'# SECURITY WARNING: don't run with debug turned on in production!# dubug 部署时关闭 *DEBUG = True# 只允许外界通过特定地址访问ALLOWED_HOSTS = []# Application definition# 应用名称列表 自己创建的应用需要添加到列表中 *INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'article', 'blog',]# django 自带的中间件工具MIDDLEWARE_CLASSES = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.auth.middleware.SessionAuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]# 路由指向ROOT_URLCONF = 'my_blog.urls'# 模板配置 * 可以在BACKEND字段中更改想要的模版引擎TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,]# 服务器设置WSGI_APPLICATION = 'my_blog.wsgi.application'# Database# https://docs.djangoproject.com/en/1.9/ref/settings/#databases# 数据库配置文件 *当前已改为mysqlDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django_blog', 'USER': 'root', 'PASSWORD': '密码', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;&#125;# Password validation# https://docs.djangoproject.com/en/1.9/ref/settings/#auth-password-validators# 密码认证相关AUTH_PASSWORD_VALIDATORS = [ &#123; 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', &#125;,]# Internationalization# https://docs.djangoproject.com/en/1.9/topics/i18n/# 时间语言配置等 *#LANGUAGE_CODE = 'en-us'#设置为汉语LANGUAGE_CODE = 'zh_Hans'TIME_ZONE = 'UTC'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.9/howto/static-files/# 静态文件地址STATIC_URL = '/static/' 需要更改和常用配置的在注释中加了*号。]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django 初学(三)mysql]]></title>
    <url>%2F2017%2F03%2F11%2Fpython%2Fdjango_base03%2F</url>
    <content type="text"><![CDATA[mysql安装虽然网上推荐去官网下载安装包进行安装，但是我还是选择了用brew直接安装，安装前一定要将之前安装的mysql卸载完整，附卸载mysql完整命令：12345678910111213141516ps -ax | grep mysql stop and kill any MySQL processesbrew remove mysqlbrew cleanupsudo rm /usr/local/mysqlsudo rm -rf /usr/local/var/mysqlsudo rm -rf /usr/local/mysql*sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plistsudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My*launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist#edit /etc/hostconfig and remove the line MYSQLCOM=-YES-rm -rf ~/Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /private/var/db/receipts/*mysql*#edit ~/.bash_profile and remove any aliases for mysql or mysqlAdmin 之后重启mac，打开终端进行安装（注意我安装的是mysql5.6版本的，因为之前安装5.7版本各种报错尝试了各种办法也无法解决）：12brew install homebrew/versions/mysql56mysql --version 输入查看版本号命令之后显示版本号表示成功，之后按照brew安装mysql的提示输入（注意mac下的文件操作权限问题，很尴尬可以对/usr/local/mysql整个文件夹及子文件夹设置读写权限）：123unset TMPDIRmysql_install_db --verbose --user=`whoami` --basedir="$(brew --prefix mysql)" --datadir=/usr/local/var/mysql --tmpdir=/tmpmysql.server start 数据库启动。 安装数据库驱动使用pip安装驱动：123456#官方驱动，没有安装成功pip install mysql-connector-python --allow-external mysql-connector-python# 支持到python3.4 我用的python 3.5pip install MySQLdb# 最终选择pip install PyMysql 这里有个坑是配置好setting.py后，启动服务会报错找不到Module ‘MySQLdb’,看python3+Django+MySQL+pymysql后，在站点的__init__.py文件中添加:12import pymysqlpymysql.install_as_MySQLdb() 成功。 同步数据库命令12python manager.py makemigrations python manager.py migrate]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django 初学(二)]]></title>
    <url>%2F2015%2F11%2F03%2Fpython%2Fdjango_base02%2F</url>
    <content type="text"><![CDATA[django路由和模板的初步学习 #利用路由对地址栏获取和操作假设之前建立的项目名称叫testPython工程名字叫learn，进入learn/views.py文件：123456789101112from django.shortcuts import renderfrom django.http import HttpResponse def add(request): a = request.GET['a'] b = request.GET['b'] c = int(a)+int(b) return HttpResponse(str(c))def add2(request, a, b): c = int(a) + int(b) return HttpResponse(str(c)) 再进入testPython/urls.py文件：123456789from django.conf.urls import urlfrom django.contrib import adminfrom calc import views as calc_views urlpatterns = [ url(r'^add/$', calc_views.add, name='add'), url(r'^add/(\d+)/(\d+)/$', calc_views.add2, name='add2'), url(r'^admin/', admin.site.urls),] 这样我们可以通过地址栏进行两个参数的加减法运算：1.第一种为传参运算，在浏览器地址栏中输入http://127.0.0.1:5000/learn/add/?a=4&amp;b=5页面显示结果为9；2.为地址运算，在地址栏输入http://127.0.0.1:5000/learn/add/7/8/页面小时结果为15. ##路由中url的name属性name属性主要用来对应模板文件，修改learn/views.py:12345from django.http import HttpResponsefrom django.shortcuts import renderdef index(request): return render(request, 'home.html') render是渲染模板的函数，此时之前应该已修改项目目录下的settings.py文件，把learn加入了app列表中。随后在learn文件中新建文件夹templates并在文件夹中新建文件：home.html,在learn/templates/home.html中写入：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="/learn/add?a=4&amp;b=5"&gt;计算 4+5&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 然后在testPython/urls.py文件中继续添加：1234567urlpatterns = [ # url(r'^learn/index/$',learn.views.index), url(r'^admin/', admin.site.urls), url(r'^learn/add/$',learn.views.add,name="add"), url(r'^learn/add/(\d+)/(\d+)/$',learn.views.add2,name="add2"), url(r'^$',learn.views.index,name="home"),] 这样用浏览器输入http://127.0.0.1:5000/就进入了home页，点击链接后跳转到计算页面，进行计算。 ##django模板虽然在实际的开发过程中通常会采用前后分离的开发方式，模板渲染的过程会交给前端js来完成，但是有一些常见的参数还需要在django中完成获取和渲染，还有部分参数需要django放置到html的隐藏域中，js通过dom操作来获取。进入learn/views.py，修改为：12345678import jsondef index(request): page_info=&#123; "pageName":"home", "pageNum":0, "pageList":["jquery","ng","underscore","echarts"] &#125; return render(request,'learn/home.html',&#123;"pageInfo":json.dumps(page_info)&#125;) 注意，python的字典必须用json.dumps()转换为前端可以识别的json格式，否则前端无法转换为对象。再打开learn/templates/learn/home.html进行更改(注意，一定要在templates文件夹下建一个和app名字相同的文件夹，html文件要放在这个文件夹下，这样可以防止多个app中的html文件名字冲突导致django识别模版错误)：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="/learn/add?a=4&amp;b=5"&gt;计算 4+5&lt;/a&gt;&lt;h2&gt;&#123;&#123;request.path&#125;&#125;&lt;/h2&gt;&lt;h3&gt;当前网址&lt;/h3&gt;&lt;h2&gt;&#123;&#123;request.GET.urlencode&#125;&#125;&lt;/h2&gt;&lt;h3&gt;当前get参数&lt;/h3&gt;&lt;script type="text/javascript"&gt; var domNew=document.getElementById('pageInfo'); var domInfo=domNew.getAttribute("backInfo"); console.log(domInfo); var infoDic=JSON.parse(domInfo);//把json格式的字符串转换为js的对象 console.log(infoDic); console.log(infoDic.pageNum);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后访问http://127.0.0.1:5000/?getInofo=1打开控制台在控制台中就可以看到输出内容123&#123;"pageName": "home", "pageList": ["jquery", "ng", "underscore", "echarts"], "pageNum": 0&#125;&#123;pageName: "home", pageList: Array[4], pageNum: 0&#125;0 页面显示出当前网址和get的参数。]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django 初学(一)]]></title>
    <url>%2F2015%2F10%2F10%2Fpython%2Fdjango_base01%2F</url>
    <content type="text"><![CDATA[利用python django搭建简单的网站，环境是mac，python2.7版本，django1.9版本 django的安装1.mac集成python2.7，省去了安装步骤，若是想用新版本，可以用brew安装。python的包管理系统是pip，类似于node的npm。在python的安装包中集成直接运行：1pip install django django默认安装到了全局。 项目创建换到项目目录，运行：1django-adimn.py startproject 项目名称 创建工程1django-adimn.py startapp 工程名称 更改配置文件用编辑器打开项目目录下的setting.py，添加应用，找到数组INSTALLED_APPS，增加工程名称：123INSTALLED_APPS = [ "工程名称",] 注意，添加的项目名称，和之前创建的工程名称一定要一致。还可以在配置文件中修改时区TIME_ZONE，主要语言LANGUAGE_CODE，数据库相关DATABASES等 修改路由（中间件）进入项目目录下的urls.py,添加：123urlpatterns = [ url(r'^工程名称/index/$','工程名称.views.index'),] 更改视图文件进入工程文件里的view.py,输入：1234from django.http import HttpResponse# Create your views here.def index(req): return HttpResponse('&lt;h1&gt;hello django&lt;h1&gt;') 启动服务查看网页shell在终端中运行：1python manage.py runserver 在浏览器中打开127.0.0.1:8000/项目名称/index,查看网页]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2015%2F10%2F02%2Ftools%2Fmarkdown_base%2F</url>
    <content type="text"><![CDATA[markdown的语法简单，效果美观，而且通用性不差，网上已经有很多教程了，这里记录一些基本的语法，和一些复杂的方法以做备忘录。 概述Markdown 的目标是实现「易读易写」。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、 &lt;pre&gt;、 &lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的强调会没有效果。HTML 的区段（行内）标签如 &lt;span&gt;、 &lt;cite&gt;、 &lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 在 HTML 文件中，有两个字符需要特殊处理： &lt;和 &amp; 。 &lt;符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。 常用标签1.标题标题是最为常用的格式，而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。例如：123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：# 和「一级标题」之间强烈建议保留一个字符的空格，这是最标准的 Markdown 写法。 2.列表列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了，例如：123- 文本1- 文本2- 文本3 如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如：1231. 文本12. 文本23. 文本3 注：-、1.和文本之间要保留一个字符的空格。 3.代码引用需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。如果引用的语句为多行，可以将```置于这段代码的首行和末行。 4.普通引用在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了。注：&gt; 和文本之间要保留一个字符的空格。 5.链接和图片在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [显示文本](链接地址)这样的语法即可，例如：1[简书](http://www.jianshu.com) 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 ![](图片链接地址) 这样的语法即可，例如：1![](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg) 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。 高级用法1.表格markdown的表格还是不太好用的，虽然也算比较直观。12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 :表示居中方式。 2.自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：1&lt;http://example.com/&gt; 显示为：http://example.com/ 3.删除线使用 ~~ 表示删除线。1~~这是一段错误的文本。~~ 显示为：这是一段错误的文本。 4.todo列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：1234- [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 显示为： [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 5.水平分隔线用***表示水平分隔线显示如： 6.注脚（支持性不友好）使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 代码速查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263641 标题与文字格式标题# 这是 H1 &lt;一级标题&gt;## 这是 H2 &lt;二级标题&gt;###### 这是 H6 &lt;六级标题&gt;文字格式**这是文字粗体格式***这是文字斜体格式*~~在文字上添加删除线~~2 列表无序列表* 项目1* 项目2* 项目3有序列表1. 项目12. 项目23. 项目3 * 项目1 * 项目23 其它图片![图片名称](http://gitcafe.com/image.png)链接[链接名称](http://gitcafe.com)引用&gt; 第一行引用文字&gt; 第二行引用文字水平线***代码`&lt;hello world&gt;`代码块高亮\`\`\`ruby def add(a, b) return a + b end\`\`\`表格 表头 | 表头 ------------- | ------------- 单元格内容 | 单元格内容 单元格内容l | 单元格内容 参考Ruby Hacking Guide 中文版-Markdown语法小结 献给写作者的 Markdown 新手指南 Markdown 语法说明 (简体中文版)]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql初始安装的一些问题]]></title>
    <url>%2F2015%2F03%2F10%2Fpython%2Fmysql_base01%2F</url>
    <content type="text"><![CDATA[网上的一些教程操作mysql的要不是windows环境，或者是linux环境，在mac上搭建虽然和linux差不多，但是还是略有不同，下面是我遇到的一些问题： 密码重置mac环境利用安全模式重置mysql root的密码:基本的思路是，以安全模式启动mysql，这样不需要密码可以直接以root身份登录，然后重设密码。首先，我们停掉MySQL服务：1mysql.server stop 以安全模式启动MySQL：1mysqld_safe --skip-grant-tables --skip-networking &amp; 注意我们加了–skip-networking，避免远程无密码登录 MySQL。这样我们就可以直接用root登录，无需密码：1mysql -u root 接着重设密码：1234mysql&gt; use mysql; mysql&gt; update user set password=PASSWORD("newPassword") where User='root'; mysql&gt; flush privileges; mysql&gt; quit 注意，命令后需要加分号。重设完毕后，我们退出，然后启动 MySQL 服务：12mysql.server restartmysql -u root -p 输入密码之后就进入了数据库。 默认端口修改mac下通过brew安装mysql时是没有my.cnf配置文件的，简单的可以通过ruby一行命令来自动生成：1sudo cp $(brew --prefix mysql)/support-files/my-default.cnf /etc/my.cnf 当然也可以自己创建一份/etc/my.cnf，附上linux的一份my.cnf:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133## The MySQL database server configuration file.## You can copy this to one of:# - "/etc/mysql/my.cnf" to set global options,# - "~/.my.cnf" to set user-specific options.## One can use all long options that the program supports.# Run program with --help to get a list of available options and with# --print-defaults to see which it would actually understand and use.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html# This will be passed to all mysql clients# It has been reported that passwords should be enclosed with # ticks/quotes escpecially if they contain "#" chars...# Remember to edit /etc/mysql/debian.cnf when changing # the socket location.[client]port = 3306#socket = /var/run/mysqld/mysqld.sock# Here is entries for some specific programs# The following values assume you have at least 32M ram# This was formally known as [safe_mysqld]. Both versions # are currently parsed.[mysqld_safe]#socket = /var/run/mysqld/mysqld.sock#nice = 0[mysqld]## * Basic Settings### * IMPORTANT# If you make changes to these settings and your system uses # apparmor, you may also need to also adjust # /etc/apparmor.d/usr.sbin.mysqld.##user = mysql#socket = /var/run/mysqld/mysqld.sockport = 3306#basedir = /usrdatadir = /usr/local/var/mysql#tmpdir = /tmpskip-external-locking## Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.bind-address = 127.0.0.1## * Fine Tuning#key_buffer = 16Mmax_allowed_packet = 16Mthread_stack = 192Kthread_cache_size = 8# This replaces the startup script and checks MyISAM tables if needed# the first time they are touchedmyisam-recover = BACKUP#max_connections = 100#table_cache = 64#thread_concurrency = 10## * Query Cache Configuration#query_cache_limit = 1Mquery_cache_size = 16M## * Logging and Replication## Both location gets rotated by the cronjob.# Be aware that this log type is a performance killer.# As of 5.1 you can enable the log at runtime!#general_log_file = /var/log/mysql/mysql.log#general_log = 1log_error = /usr/local/var/mysql/MacBook15.local.err# Here you can see queries with especially long duration#log_slow_queries = /var/log/mysql/mysql-slow.log#long_query_time = 2#log-queries-not-using-indexes## The following can be used as easy to replay backup logs or # for replication.# note: if you are setting up a replication slave, see # README.Debian about other settings you may need # to change.#server-id = 1#log_bin = /var/log/mysql/mysql-bin.logexpire_logs_days = 10max_binlog_size = 100M#binlog_do_db = include_database_name#binlog_ignore_db = include_database_name## * InnoDB## InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.# Read the manual for more InnoDB related options. There are many!## * Security Features## Read the manual, too, if you want chroot!# chroot = /var/lib/mysql/## For generating SSL certificates I recommend the OpenSSL GUI "tinyca".## ssl-ca=/etc/mysql/cacert.pem# ssl-cert=/etc/mysql/server-cert.pem# ssl-key=/etc/mysql/server-key.pem# Query Cachingquery-cache-type = 1# Default to InnoDBdefault-storage-engine=innodb[mysqldump]quickquote-namesmax_allowed_packet = 16M[mysql]#no-auto-rehash # faster start of mysql but no tab completition[isamchk]key_buffer = 16M mysql常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#查看端口号show variables like 'port';#创建数据库create database name;#查看数据库show databases;show create database name; #删除数据库drop database name;#进入数据库use name;#查看当前数据库名称select database();#创建数据表create table name(username varchar(20),age tinyint unsigned,salary float(9,2) unsigned);#查看数据表show tables;show tables from name;#查看条目show columns from name;#插入记录insert name values('tom',25,7681.10);#插入所选记录的内容insert tb1(username,salary) values('john',4500.88);#用表达式插入单挑记录指定字段（set）instert tb1 set username='tom',salary='8000';#查看表详细内容select * from name;#添加单列alter table name add cName tinyint unsigned not null default 10;#删除单列alter table name drop cName;#修改列定义(modify和change)alter table name modify int(2) first;alter table name change name newName int(2);#更新记录update name set age=10,pwd='123' where id=1;#查询语句select name.id,name.username form name;#查询分组select name.id,name.sex from name group by sex;#查询分组条件select name.id,name.sex from name group by sex having id&gt;2;#查询结果分组,前面字段若有重复按照第二字段继续排序select * from name order by age, id desc;#限制查询结果条目数 从0 开始后的3条select * from name limit 0,3;#有条件的插入其他表中的记录到当前表insert name(age) select age from othername where age&gt;8 limit 1,2; mysql 约束非空约束not null主键约束primary key唯一约束unique key默认约束default外键约束foreign key]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo装饰(三)]]></title>
    <url>%2F2015%2F02%2F13%2Fhexo%2Fhexo_decorateBlog3%2F</url>
    <content type="text"><![CDATA[light主题文章前小标题替换light在主页列表页和详情页的文章标题前有一个paper的小icon：这个icon是FontAwesome图标字体，可以在FontAwesome图标字体官网上找一个喜欢的icon,点开记住它的Unicode。打开/themes/light/source/css/_partial/article.styl文件对下面代码进行替换：1234&amp;.post .icon &amp;:before content '\f016' /* 替换成之前记住的Unicode*/ 这个方法适用于其他地方的小icon更改，官网的icon字体更新了不少，你可以在ejs文件模板中找到对应的字体引入链接，改成最新的，甚至可以找到别的图标字体进行替换。值得一提的是引入过多的字体会影响网页的加载速度，若是对icon有要求甚至可以采用自己切图制作，这里就不在赘述。]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo装饰(二)]]></title>
    <url>%2F2015%2F02%2F11%2Fhexo%2Fhexo_decorateBlog2%2F</url>
    <content type="text"><![CDATA[设置分类列表在_config.yml中设置categories:会让文章属于哪个分来，如果分类用了中文的话，路径也会出现中文，这不是我们想看到的效果，这时在配置文件中的Category &amp; Tag可以更改分类的路径，类似于：1234567# Category &amp; Tagdefault_category: uncategorizedcategory_map: 编程: programming 生活: life 其他: othertag_map: light主题格式优化light主题的引用模块和强调模块不太符合我的审美，找到了/themes/light/source/css/_partial/article.styl，后面加入1234567891011.entry em background #ddd font-style normal padding 0 4pxarticle .entry blockquote border-left 5px solid #ddd; background #eee; font-size: 14px; padding: 5px 30px 15px; text-align: left; 其实就是对css格式的更改，这里要吐槽一下styl这种格式，一看就是python和ruby开发者搞出的东西，类似于jade这种反人类的语法，牺牲开发效率体现优雅。。。 light主题增加文章导航网上找了写增加导航的方法，但是不适用与light主题，自己看了下官方api，文章导航主要借助了hexo提供的辅助函数toc：123&lt;%- toc(str, [options]) %&gt;&lt;!-- 事例--&gt;&lt;%- toc(page.content) %&gt; 其实就是在toc函数中传入内容就行了。导航的位置根据不同的主题略有不同，网上很多主题是直接放在了/layout/_partial/article.ejs中，但是对于类似于light这样左右布局的主题，导航放在文章区域不太好调控样式，这样的主题导航适合放在右侧的sidebar中。但是直接放在sidebar中有一个问题，因为sidebar不仅仅在详情页面出现，而且会在主页和列表也出现，直接用上述方法的话在静态化编译的时候hexo直接会报错，而且导致主页和列表页无法打开，为了解决这个问题，引入了辅助函数：1&lt;%- is_post() %&gt; 通过这个函数可以判断页面是否是详情页。所以给light主题在右侧侧边栏添文章导航的方法是：1.在/themes/light/layout/_widget中新建文件toc.ejs2.在toc.ejs中填入以下代码：123456&lt;%if(is_post())&#123; %&gt;&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt; &lt;%- toc(page.content) %&gt;&lt;/div&gt;&lt;%&#125;%&gt; 3.在/themes/light/_config.yml中更改相关内容：12345widgets:- toc #新增文章导航- search- category- tagcloud 4.在/themes/light/source/css/_partial/archive.styl中修改文章导航的样式比如增加：123456789101112131415161718#toc background #fff box-shadow 1px 2px 3px #ddd padding 15px 20px line-height 1.6 font-size 14px margin-bottom 30px strong font-size 15px ol margin-top 5px margin-left 0 .toc padding 0 li list-style-type none .toc-child padding-left 20px 5.在/themes/light/layout/layout.ejs中找到1&lt;aside id=&quot;sidebar&quot; class=&quot;alignright&quot;&gt;&lt;%- partial(&apos;_partial/sidebar&apos;, &#123;&#125;, &#123;cache: true&#125;) %&gt;&lt;/aside&gt; 将cache:true改为cache:false因为这里调用了缓存机制，不关闭缓存机制的话在文章页面会继承首页的sidebar，文章列表不会出现。 文章导航优化这样一个light主题的文章导航的最基本样式就添加完成了，但是发现现在的文章导航是固定在sidebar第一块位置上的，当文章很长时每次还得拖回到顶部去查看文章导航会很不方便。我们需要的效果是初始情况下文章导航固定在sidebar右侧位置上，然后当文章滚动后，文章导航订在右侧固定的位置也就是fixed布局。这样明显就要有js的参与了。1.首先在/themes/light/source/js中新建一个文件，名字随意，然后把以下代码考入：1234567891011121314151617181920var lb_article = (function ($) &#123; var _sideBarShow=function () &#123; var scrollTop=$("body").scrollTop(); if(scrollTop&gt;160)&#123; $("#toc").addClass("toc-articleP"); &#125;else if(scrollTop&lt;=160&amp;&amp;$("#toc").has("toc-articleP"))&#123; $("#toc").removeClass("toc-articleP"); &#125; &#125; var pub = &#123; sidebar: function () &#123; _sideBarShow() $(window).scroll(function () &#123; _sideBarShow() &#125;) &#125; &#125;return pub;&#125;)(jQuery);lb_article.sidebar(); 2.在/themes/light/layout/_partial/after_footer.ejs中引入js文件既在文件最后添加：1&lt;script src="&lt;%- config.root %&gt;js/之前建立的文件名.js"&gt;&lt;/script&gt; 3.在/themes/light/source/css/_partial/archive.styl中添加：1234#sidebar .toc-articleP position fixed width 240px background #f4f4f4 总结到了主题优化部分大多是动前端的内容，找到对应的文件进行增加和修改就可以，ejs模板比较好理解，但是styl格式对于不长些ruby之类语言的人来说较为不习惯。对于light主题的优化就到这里，随后可能会利用前端知识添加一些背景图片，更改部分字体之类的小修改。 参考GoonX的博客]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo装饰(一)]]></title>
    <url>%2F2015%2F02%2F10%2Fhexo%2Fhexo_decorateBlog%2F</url>
    <content type="text"><![CDATA[简单的部署完博客之后对博客需要进行一些装饰： 主页文章显示摘要编辑md文件的时候，在要作为摘要的文字后面添加html的more注释即可。 引入站内搜索模块 swiftype先看一下引入swifttype后的最终效果：到swiftype官网进行注册，忽略30天试用，基础服务是可以永久免费使用的。按照指引输入网址、输入引擎名称、创建搜索引擎，之后点击左侧的install Search开始生成代码复制代码后开始设置_config.yml和ejs模板文件。 1234关于ejs模板ejs模板是早先nodejs著名网站框架express的默认模板引擎，虽然后来express不知出于什么样的考虑把ejs更换成了反人类的jade，但是ejs一直是js开发者首选的模板引擎，light主题同样采用了ejs，ejs的语法简单说来就是在 &lt;% %&gt; 中填写js内容，外部填写html内容。 不同的主题需要更改的模板文件是不同的，只要找到search模块所在的地方就可以更改了，我用的是light主题，search模块是在/themes/light/layout/_widget/search.ejs中进行更改，找到form标签改为：1234&lt;form class="search" action="&lt;%- config.root %&gt;search/index.html" method="get" accept-charset="utf-8"&gt; &lt;label&gt;站内搜索&lt;/label&gt; &lt;input type="text" id="search" class="st-default-search-input" maxlength="20" placeholder="Search" /&gt; &lt;/form&gt; 之后找到处于body底部的模板文件，我的是/themes/light/layout/_partial/after_footer.ejs，把之前从swiftype网站上拷贝下来的代码添加到文件最后即可。 引入评论模块“多说”博客中添加评论模块是必不可少的，一些hexo主题中已经默认添加了“多说”评论模块，我的主题light没有默认添加，需要手动更改ejs文件进行添加。第一步进入多说官网注册账号，并按照指引点击安装，输入站点名称地址等信息。点击创建后，得到js代码。然后进入/themes/light/layout/_partial/comment.ejs中把代码改为：12345678910111213141516171819202122232425262728293031323334353637&lt;% if ( page.comments)&#123; %&gt; &lt;nav id="pagination" &gt; &lt;% if (page.prev) &#123; %&gt; &lt;a href="&lt;%- config.root %&gt;&lt;%- page.prev.path %&gt;" class="alignleft prev" &gt;&lt;%= __('prev') %&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;% if (page.next) &#123; %&gt; &lt;a href="&lt;%- config.root %&gt;&lt;%- page.next.path %&gt;" class="alignright next" &gt;&lt;%= __('next') %&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;div class="clearfix"&gt;&lt;/div&gt;&lt;/nav&gt;&lt;section id="comment"&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class="ds-thread" data-thread-key="&lt;%= page.path %&gt;" data-title="&lt;%= page.title %&gt;" data-url="&lt;%= page.permalink %&gt;"&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type="text/javascript"&gt; var duoshuoQuery = &#123;short_name:"chillax"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt; 其中short_name记得改成自己的，在之前获得的多说通用代码里有自己的short_name。 网站标签页icon设置先从网站或者运用ps制作好icon的图片格式最好为png，但是通常网站标签页上的icon格式为ico格式，很多网站又在线转换工具，可以把png格式的图片转换为ico格式的icon，我这里用的是：http://www.ico.la/，尺寸为32*32把制作好的ico文件拷贝到/source目录下，然后打开/themes/light/layout/_partial/head.ejs找到：1&lt;link href="&lt;%- config.root %&gt;favicon.png" rel="icon"&gt; 替换为：1&lt;link href="&lt;%- config.root %&gt;favicon.ico" rel="icon" type="image/x-ico"&gt; 参考引用hexo干货系列：（五）hexo添加站内搜索使用swiftype实现站内搜索hexo搭建博客的实用功能(上)(基于hexo3.0)]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime编辑器的使用（二）小技巧]]></title>
    <url>%2F2015%2F01%2F11%2Ftools%2Fsublime_base02%2F</url>
    <content type="text"><![CDATA[除了常用的插件安装功能外，sublime还有一些提供便捷的小技巧 快捷键 Command + D 选中一个单词 Command + L 选中一行 Ctrl + Command + M选中括号内所有内容 (编写CSS或JS时非常实用) 按住 Command 键再点击想选中的行 Command + Ctrl + G (选中部分文本时) 按此键选中所有相同文本 css排序CSS属性的顺序一般不重要，因为无论何种顺序浏览器都能正确渲染。但排序所有的属性还是有助于代码的整洁。在Sublime Text中，选中CSS属性后按 F5 就可以按字母顺序排序。 跨文件编辑同一个编辑操作可以在多个文件中同时重复。举个例子，多个文件中有同一段代码时，可用以下的步骤快速编辑： 按 Command + Shift + F 在 Find 框中输入待查找的代码。可按 Command + E 快速使用选择中的代码段。 在 Where 框中指定需要查找的文件范围，或填写 &lt;open files&gt;表示查找目前打开的文件。 在 Replace 框中输入要替换成的代码，按 Replace 按钮批量替换。 文件爬虫按 Command + R 可以列出文档中所有的CSS选择器。可以选择并立刻跳转查看。这个操作比使用一般的“查找”功能快得多。 更换Sublime Text程序图标在 Dribbble 上有大量重新设计的Sublime Text精美图标。更换方法：1.下载一个图标，有 .icns 格式的最好。如果没有，用 iConvert 转换之。2.终端执行： open /Applications/Sublime\ Text.app/Contents/Resources/3.替换 Sublime Text 3.icns 或 Sublime Text 2.icns 文件。 在终端中使用sublime打开文件有时候我们想在终端中用外部程序打开某个文件或者执行某个文件，以sublime text为例，希望命令行工具用sublime 打开某个文件。sublime 提供命令行的工具叫subs，路径在：1/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl 使用ln命令ln命令是做文件链接用的，不恰当的例子可以称之为建立快捷方式。1ln /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl 如上命令是将sublime提供的subl命令链接到usr/local/bin/subl 这个路径上来，usr/local/bin 这个文件夹是全局都可以访问到的命令所在的目录，都是我们自己下载安装的一些命令行工具链接所在地 比如npm、httpie等.]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>代码编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime编辑器的使用（一）插件安装]]></title>
    <url>%2F2015%2F01%2F10%2Ftools%2Fsublime_base01%2F</url>
    <content type="text"><![CDATA[Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。 虽然近几年visual sudio code和atom编辑器的崛起分流了部分sublime的使用者，但是sublime急速打开速度，和流畅的操作体验还是前二者无法比拟的。 sublime插件安装 按Ctrl+`调出console（注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音）粘贴以下代码到底部命令行并回车：1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 重启Sublime Text 3。如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。按下Ctrl+Shift+P调出命令面板输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 sublime插件推荐1.emmet 快速生成HTML代码段的插件，强大到无与伦比:可以超快速编写HTML/CSS/JS。 可以说是前端工程师、美工必备的插件了，可以说没有emmet的sublime是不完备的。emmet极大的简化了html语法，在vscode和webstorm等ide中都默认集成了，关于emmet的语法有时间我会抽空另开一篇博客详细描述，这里只需要记住强大的tab键即可。 2.Autoprefixer 这是一款CSS3私有前缀自动补全插件；该插件使用CanIUse资料库（当然，SublimeText自然也有CanIUse这个插件咯），能精准判断哪些属性需要什么前缀，与CssComb插件一样，该插件也需要系统已安装Node.js环境；使用方法：在输入CSS3属性后（冒号前）按Tab键即可。 当前大部分私有前缀补全的工作都由代码部署工具来完成了，编辑器中的相关插件只是后备选择。 3.HTML-CSS-JS Prettify 一款集成了格式化（美化）html、css、js三种文件类型的插件，即便html,js写在PHP文件之内。插件依赖于nodejs，因此需要事先安装nodejs，然后才可以正常运行。插件安装完成后，快捷键ctrl+shift+H完成当前文件的美化操作。详情请参照 sublime text 3 插件：HTML-CSS-JS Prettify 4.SFTP顾名思义，方便编辑完成后直接ftp上传到服务器的插件。需要简单的配置一下，具体看：在 Sublime Text 2 中使用 SFTP 插件快速编辑远程服务器文件 5.All autocompleteSublime Text 默认的 Autocomplete 功能只考虑当前的文件，而 AllAutocomplete 插件会搜索所有打开的文件来寻找匹配的提示词。 6.git和GitGutter方便在sublime中操作git，GitGutter能更好的帮助开发者查看文件之前的改动和差异 7.svn工作中避免不了使用svn。。。 8.Auto filename自动补全引用文件的路径。 9.SideBarEnhancementsSideBarEnhancements是一款很实用的右键菜单增强插件；在安装该插件前，在Sublime Text左侧FOLDERS栏中点击右键，只有寥寥几个简单的功能；安装了就相当于给其丰了大胸一般。 10.各种框架、类库、语言相关插件sublime 的较为友好的插件机制让很多开发者都贡献了很多优质插件，只需要在comman+shift+p输入install package,然后在打开的窗口中搜索相关类库框架的名称就可以：如搜索jquery,可以找到jquery相关的插件。 插件安装问题 解决sublime package control 出现 There are no packages available for installation。 是因为http://packagecontrol.io/channel_v3.json 获取失败，这个文件是package的列表，找台能翻墙的电脑，把channel_v3.json文件复制下来。放在本地的服务器上，然后进入package control的settings中把里面的http://packagecontrol.io/channel_v3.json替换成http://127.0.0.1:8080/Documents/channel_v3.json123&quot;channels&quot;: [ &quot;http://127.0.0.1:8080/Documents/channel_v3.json&quot; ] 保存退出，开启本地服务器，然后就能安装插件了。 引用：如何优雅地使用Sublime Text]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>代码编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建]]></title>
    <url>%2F2014%2F11%2F07%2Fhexo%2Fhexo_newBegining%2F</url>
    <content type="text"><![CDATA[既然是第一篇就说说hexo在搭建的时候的一些问题吧：（感谢hexo很完善的官方文档） 环境node和git是最基本的了，mac上通过brew安装也毫无难度，这里注意一下的就是node的版本，我用了nvm做版本管理，刚开始用node的v6.2安装了hexo，会报错一大篇，网上查了一下，说是无关紧要的错误但是比较烦心的是每次执行命令的时候这些错误都会报出来，错误类似于：1&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 网上找到用1$ npm install hexo --no-optional 安装可以解决，但是我最终还是选择降级回了node的 v0.12版本 hexo安装12345npm install hexo-cli -g --savecd bloghexo init//在目录结构下会自动再安装一次hexonpm install hexo-deployer-git --save 这些都没有什么问题。hexo-deployer-git 这个包是一会儿用来自动部署到github pages用的1234hexo g//静态化网页hexo s -p 5000//在5000接口监听网页 这时就可以在localhost:5000上看到hellow world 的欢迎页了 配置文件在根目录下的_config.yml中可以配置绝大多数工能官方文档中已经非常详细的讲解了文档中的功能含义（国人开发的就是好。。。）这里摘录一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657网站参数 描述title 网站标题subtitle 网站副标题description 网站描述author 您的名字language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。网址参数 描述 默认值url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/permalink_default 永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。目录参数 描述 默认值source_dir 资源文件夹，这个文件夹用来存放内容。 sourcepublic_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 publictag_dir 标签文件夹 tagsarchive_dir 归档文件夹 archivescategory_dir 分类文件夹 categoriescode_dir Include code 文件夹 `downloads/codei18n_dir 国际化（i18n）文件夹 :langskip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章参数 描述 默认值new_post_name 新文章的文件名称 :title.mddefault_layout 预设布局 postauto_spacing 在中文和英文之间加入空格 falsetitlecase 把标题转换为 title case falseexternal_link 在新标签中打开链接 truefilename_case 把文件名称转换为 (1) 小写或 (2) 大写 0render_drafts 显示草稿 falsepost_asset_folder 启动 Asset 文件夹 falserelative_link 把链接改为与根目录的相对位址 falsefuture 显示未来的文章 truehighlight 代码块的设置 分类 &amp; 标签参数 描述 默认值default_category 默认分类 uncategorizedcategory_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。参数 描述 默认值date_format 日期格式 MMM D YYYYtime_format 时间格式 H:mm:ss分页参数 描述 默认值per_page 每页显示的文章量 (0 = 关闭分页功能) 10pagination_dir 分页目录 page扩展参数 描述theme 当前主题名称。值为false时禁用主题deploy 部署部分的设置 吐槽yaml之前就知道yaml是个神奇的东西，好多情况下用来写配置文件，但是这个格式的语法要求很严格，特别注意在：后需要一个空格不能是tab，最好借助编辑器的语法检测来进行编辑否则会报各种奇葩错误类似：1234TypeError: Cannot read property 'replace' of null at /Applications/XAMPP/xamppfiles/htdocs/lanbos.github.io/node_modules/hexo/lib/hexo/load_config.js:34:30 at tryCatcher (/Applications/XAMPP/xamppfiles/htdocs/lanbos.github.io/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Applications/XAMPP/xamppfiles/htdocs/lanbos.github.io/node_modules/hexo/node_modules/bluebird/js/release/promise.js:509:31) Deployment配置1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 在_config.yml中配置最后的Deployment选项并下载之前说过的hexo-deployer-git插件就可以直接通过命令hexo d -g生成静态文件并提交到github上 写新文章官方文档中推荐使用new命令来新建新文章，我的做法是直接在source/_postts文件夹下新建markdown文件来增加新文章，文章的开头需要添加一些yaml命令12345678title: ##文章标题date: ##时间，格式为 YYYY-MM-DD HH:mm:sscategories: ##分类tags: ##标签，多标签格式为 [tag1,tag2,...]keywords: ##文章关键词，多关键词格式为 keyword1,keywords2,...description: ##文章描述toc: true ##在此处设定是否开启目录，需要主题支持。--- 图片插入可以采用官方提供的两种方法：1.最简单的方法就是将图片放在 source/images 文件夹中，然后通过markdown的语法：1![](/images/image.jpg) 来访问图片。2.通过资源引用方式，先在_config.yml中将post_asset_folder 设置为true，之后引用官方文档原话：当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。另外可以用最传统的图床方法，也比较好，网上有很多用七牛云做图床的教程，我是在google上搜到的一个免费图床http://tuchuang.org/。chrome插件商店中的微博图床也是个很好的选择。网络上提供的图床可能不稳定，所以最好把关键的图片使用官方的方法引入，不重要的图片采用图床的方式。 更改域名在source文件夹下新建一个名为CNAME的文件（注意：不添加任何后缀），文件中写入你的域名1lanbos.win 域名购买及DNS解析在阿里云购买的域名。。。会有备案等一系列流程，就不在这里赘述了，跟着阿里云的提示步骤走不会出太大的问题，一些小众的后缀域名会很便宜，如.win,.xyz,.top等。通过：1ping yourname.github.io 来获得你github pages的IP地址在阿里云找到域名相关选项：点击后把之前获得的ip填进去，大约一分钟后就可以把你购买的域名关联到你的github pages上，在浏览器输入你的域名尝试访问一下，就完成了域名绑定。 后续hexo基础搭建博客的方式就写到这里，随后会尝试在主题方便做一些更改和增加 参考文章史上最详细的Hexo博客搭建图文教程Hexo常见问题解决方案MAC 上 github + hexo 搭建博客教程]]></content>
      <categories>
        <category>码畜相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
